<html><head><meta charset="UTF-8"/></head><body><div id="ref-help" class="section"><h1>Mind the Gap 冬季ワークショップ Javascript/Processing.js</h1>

<ul>
<li><a href="#ref-PJSStep0">はじめに</a>

<ul>
<li><a href="http://bit.ly/mtg-winter-js">独立のワークショップ資料</a></li>
</ul></li>
<li><a href="#ref-PJSStep1">Step 1: キャンバス</a></li>
<li><a href="#ref-PJSStep2">Step 2: 色</a></li>
<li><a href="#ref-PJSStep3">Step 3: アニメーション</a></li>
<li><a href="#ref-PJSStep4">Step 4: マウスの使い方</a></li>
<li><a href="#ref-PJSStep5">Step 5: キーボードの使い方</a></li>
<li><a href="#ref-PJSStep6">Step 6: シミュレーション</a></li>
<li><a href="#ref-PJSStep7">Step 7: 画像と音</a></li>
<li><a href="#ref-PJSStep8">Step 8: ゲームサンプル</a></li>
<li><a href="https://forms.gle/kqJvxbtT3UsX4muR8">作品の提出フォーム</a></li>
<li><a href="http://bit.ly/mtg-survey-2021">アンケート</a></li>
<li>ヘルプ

<ul>
<li><a href="#ref-index">索引</a></li>
<li><a href="#ref-Tools">ツール</a></li>
<li><a href="#ref-Demos">デモ</a></li>
<li><a href="#ref-Games">ゲーム</a></li>
<li><a href="#ref-ImageLibrary">画像リスト</a></li>
<li><a href="#ref-SoundLibrary">音のリスト</a></li>
</ul></li>
</ul>

</div><div id="ref-PJSStep0" class="section"><h1>はじめに</h1>

<p>このワークショップの目的は、皆さんにプログラミングを体験していただき、コンピューターサイエンスは誰でも気軽に楽しめるものだということを知っていただくことです。そこで、本日は皆さんに簡単なゲームかアニメーションを作っていただきます。</p>

<p>今回はJavascriptというプログラミング言語を使います。プログラミング言語にはライブラリというものがあります。ライブラリとはプログラムの再利用できる部品をあつめたものです。Javascriptの場合は、他のプログラミング言語と比べて、ライブラリが特に豊富です。本日はProcessing.jsというJavascriptのライブラリを使ってプログラムを作ります。今回は本ワークショップ専用のページを使いますが、Javascriptはライブラリの種類も多く、様々な使い方があり、とても実用的なプログラミング言語です。</p>

<p>左側にプログラムを打ち込んで実行すると右側のキャンバスに結果が表示されます。</p>

<p>機能の説明やサンプルプログラムはヘルプから見られます。プログラムを打ち込むと自動的に実行されて、すぐにキャンバスに結果がでます。右側キャンパス下のRestartボタンを押すことで再実行できます。</p>

<p>プログラムに何か問題があるとキャンバスの上に「Oh noes!」というメッセージが出ます。この場合、プログラムの修正が必要です。「Show me where」をクリックすると、プログラムの問題がある部分を示してくれます。不明な点があれば、社員のTAに遠慮なく質問してください。</p>

<p><img src="images/oh-noes.png" alt="oh-noes"/></p>

<p>ワークショップ中に出ているサンプルプログラムは全てヘルプに含まれています。タイピングが難しい場合や、いちいち入力していると講義に追い付けなくなりそうな場合は、ヘルプから読み込むことができます。</p>

<p><img src="images/help1.png" alt="Help button"/>
<img src="images/help2.png" alt="Help link"/>
<img src="images/load1.png" alt="Load program"/></p>

<p>開発中に別のサンプルプログラムを試したいときは、「New」 ボタンをクリックします。すると新しいタブが開いて新たにサンプルプログラムが表示されます。元のタブに戻ると、これまでのプログラムが継続して編集できます。</p>

<p><img src="images/new1.png" alt="New program"/></p>

<p>「Program name」のところを使ってプログラムに名前をつけることができます。「My projects」をクリックすると、前に編集したプログラムのリストが出ますので、前に作ったプログラムに簡単に戻れます。</p>

<p>プログラムの中に現れる単語や関数が分からないときは、ヘルプを使ってみましょう。</p>

<p>次は<a href="#ref-PJSStep1">ステップ1</a>へ。</p>

</div><div id="ref-PJSStep1" class="section"><h1>ステップ１: キャンバス</h1>

<p>コンピューターグラフィックでは、x座標は数学と同じように右に向かって増えますが、y座標は普通の数学とは反対で下に向かって増えます。</p>

<p>プログラムを書く画面のときはキャンバスはいつも約 400 × 400ですが、フルスクリーン（Fullscreen ボタンをクリック）でプログラムを実行するときはみなさんのパソコンの画面の大きさによってキャンパスのサイズが変わります。width や height の変数を使って大きさを調べることができます。</p>

<pre><code class="language-render">function arrow(x1, y1, x2, y2) {                                                                    
  line(x1, y1, x2, y2);                                                                             
  var x = x2-x1;
  var y = y2-y1;
  var l = sqrt(x*x+y*y);                                                                            
  x = x / l * 10;                                                                                   
  y = y / l * 10;
  var alpha = 45;
  line(x2, y2, x2 - x*cos(alpha) + y*sin(alpha), y2 - x*sin(alpha) - y*cos(alpha));                 
  line(x2, y2, x2 - x*cos(-alpha) + y*sin(-alpha), y2 - x*sin(-alpha) - y*cos(-alpha));             
} 
  
size(150, 150, &#34;2D&#34;);
arrow(10, 20, width-20, 20);                                                                        
arrow(20, 10, 20, height-20);                                                                       
fill(0);
text(&#34;(0,0)&#34;, 1, 11);
text(&#34;x&#34;, width-20, 37);                                                                            
text(&#34;y&#34;, 30, height-15); 
</code></pre>

<pre><code class="language-example">// WidthAndHeightExample
fill(0,0,0);
textSize(15);
text(&#34;width: &#34; + width, 10, 50);
text(&#34;height: &#34; + height, 10, 80);
</code></pre>

<p>同じように、座標を使って様々な図形を描くことができます。
よく使うのは rect(), ellipse(), line() です。</p>

<p><img src="images/rect.png" alt="images/rect.png"/>
<img src="images/ellipse.png" alt="images/ellipse.png"/>
<img src="images/line.png" alt="images/line.png"/></p>

<p>例えば、こちらのプログラムを打ち込んでみましょう。　または、ヘルプの中に「Step1」にクリックして、そのプログラムの「読み込む」ボタンを押しましょう。</p>

<pre><code class="language-prerender">// RectEllipseLine
rect(10, 10, 80, 40);
ellipse(50, 75, 80, 40);
line(10, 60, 90, 90);
</code></pre>

<p>キャンバスに右のような絵が表示されたでしょうか？
プログラムを構成する一つ一つの行を命令といいます。Javascriptでは、各命令は必ずセミコロン( ; )で終わらなければいけません。</p>

<p>数字で絵を描くと不便なので、環境に一つの役に立つツール組み込んでいます。　プログラムの中に数字のところにクリックすると、スライダーが出てきます。スライダーをマウスで押しなら左右動かすと、数字が変わって、キャンバスの絵もすぐに反応します。</p>

<p><img src="images/adjust.png" alt="Adjust constant"/></p>

<p>それでは、今習ったことを使ってみましょう。</p>

<p><strong>問題１</strong>：雪だるまを描きましょう。完成したプログラムに名前をつけましょう。
例に限らず、好きなような形の雪だるまにしましょう。</p>

<p>例として以下の雪だるまいかがでしょうか。</p>

<pre><code class="language-render">// Snowman
size(300, 300, &#34;2D&#34;);
ellipse(150, 250, 100, 100);
ellipse(150, 170, 80, 80);
ellipse(150, 110, 60, 60);
</code></pre>

<pre><code class="language-hidden">// Snowman1
ellipse(150, 250, 100, 100);
ellipse(150, 170, 80, 80);
ellipse(150, 110, 60, 60);
</code></pre>

<p>できましたか？</p>

<p>次は、<a href="#ref-PJSStep2">ステップ2</a>へ。</p>

</div><div id="ref-PJSStep2" class="section"><h1>ステップ2: 色</h1>

<p>今までの絵は白黒でしたが、それではつまらないので、色を加えてみましょう。ProcessingではRGBまたはRGBAカラーモデルを採用しています。RGBはR=Red (赤)、G=Green (緑)、B=Blue (青)から成り立っています。右の図はRGBのカラーミックスのイメージです。RGBそれぞれに0から255の数字で色の強さを指定します。</p>

<p>各図形はペンで図形の縁が描画され、内部を塗りつぶします。色を設定する命令はそれぞれにあり、ペンの色は stroke() で、塗りつぶす色は fill()で設定します。</p>

<pre><code class="language-render">function posToColor(x, y) {
  if (x &lt; width/2 &amp;&amp; y &lt; height/2) {
    return color((width/2-x)/width*512, (height/2-y)/height*512, 0);
  } else if (x &lt; width/2) {
    return color(220);
  } else if (y &lt; height/2) {
    return color(0, (height/2-y)/height*512, (x-width/2)/width*512);
  } else {
    return color((y-height/2)/height*512, 0, (x-width/2)/width*512);
  }
}

size(200, 200, &#34;2D&#34;);

for (var x = 0; x &lt; width; x++) {
  for (var y = 0; y &lt; height; y++) {
    set(x, y, posToColor(x, y));
  }
}

fill(255);
textSize(height/20);
text(&#34;(255,0,0)&#34;, 5, height/2-5);
fill(0);
textAlign(LEFT, TOP);
text(&#34;(255,255,0)&#34;, 5, 2);
textAlign(RIGHT, TOP);
text(&#34;(0,255,255)&#34;, width-5, 2);
textAlign(CENTER, TOP);
text(&#34;(0,255,0)&#34;, width/2, 2);
textAlign(LEFT, BASELINE);
fill(255);
text(&#34;(0,0,0)&#34;, width/2+2, height/2-2);
textAlign(RIGHT, BASELINE);
text(&#34;(0,0,255)&#34;, width-2, height/2);
fill(0);
textAlign(LEFT, BOTTOM);
text(&#34;(255,0,0)&#34;, width/2+2, height-2);
textAlign(RIGHT, BOTTOM);
text(&#34;(255,0,255)&#34;, width-2, height-2);
</code></pre>

<p>例えば、こちらのプログラムを打ち込んでみましょう。</p>

<pre><code class="language-prerender">// FillExample
fill(0, 255, 0);  // 塗りつぶす色
stroke(0, 0, 255);  // ペンの色
ellipse(50, 50, 80, 80);
</code></pre>

<p>右側にあるの絵のようになりましたか？</p>

<p>色の設定は、数字だけではなくて、UIツールでもできます。コードの <code>fill()</code> や<code>stroke()</code>の中の数値（245や250など）をクリックしてみてください。</p>

<p><img src="images/color1.png" alt="Color tool"/>
<img src="images/color2.png" alt="Color tool"/></p>

<p>プログラム中に出てくる、<code>//</code>から始まる文章は、コメントと呼びます。コンピューターはコメントを無視するので、プログラムの説明を入れたいときに便利です。</p>

<p>RGBAカラーモデルはRGBに加えてA=Alpha(透明度)が設定できます。例えば、内部を塗らない楕円を描くことができます：</p>

<pre><code class="language-prerender">// FillExampleAlpha
fill(0, 0, 0, 0);  // アルファは0だから、塗りつぶさない
ellipse(50, 50, 80, 80);
</code></pre>

<p>色を使わないで、明るさだけを設定するときは、RGB 3つの数は同じになるので、省略することができます:
<code>fill(0);</code>は<code>fill(0,0,0);</code>と同じ意味です。 </p>

<p>塗りつぶさないときは<code>noFill();</code>も使えます。</p>

<p>では、雪だるまに色を着けてみましょう。</p>

<p><strong>問題２</strong>：前に作った雪だるまに色を着けましょう。右に色付けの例を示します。好きな色にしてもいいです。　前に作った雪だるまのプログラムがなくなったら、「My projects」のボタンを押して戻ることができます。</p>

<pre><code class="language-render">// SnowmanColor
size(300, 300, &#34;2D&#34;);
strokeWeight(5);
stroke(255, 100, 100);
ellipse(150, 250, 100, 100);
stroke(100, 255, 100);
ellipse(150, 170, 80, 80);
stroke(100, 100, 255);
ellipse(150, 110, 60, 60);
</code></pre>

<pre><code class="language-hidden">// SnowmanColor
strokeWeight(5);
stroke(255, 100, 100);
ellipse(150, 250, 100, 100);
stroke(100, 255, 100);
ellipse(150, 170, 80, 80);
stroke(100, 100, 255);
ellipse(150, 110, 60, 60);
</code></pre>

<p>次は<a href="#ref-PJSStep3">ステップ3</a>へ。</p>

</div><div id="ref-PJSStep3" class="section"><h1>ステップ3: アニメーション</h1>

<p>今日のワークショップの目的は皆さんに自分で簡単なゲームを作ってもらうことなので、単に図形を描くだけでは足りません。図形を動かしてみましょう。</p>

<p>そのためには、同じプログラムを何回も繰り返し実行する必要があります。Processingにはアニメーションを作るのための仕組みがすでに含まれています。</p>

<p>一回だけ実行したいプログラムの部分はそのまま書き、何回も繰り返し実行したい部分はfunction draw() { … }の中に書くと、簡単なアニメーションを作れます。
このように{}で囲ったプログラムの部分は「関数」といいます。 関数は自由に作れますが、draw()という関数は特別で、自動的に何回も繰り返して実行されます。</p>

<p><img src="images/execution-diagram.png" alt="execution diagram"/></p>

<p>いくつかの例を見てみましょう。</p>

<pre><code class="language-prerender">// FrameCountTooFast
textSize(50); // 文字を大きくする
fill(0);      // 文字を黒にする

function draw() {
  text(frameCount, 10, 50);
}
</code></pre>

<p>速すぎて何が起きたかよくわかりません。実行をもう少し遅くするには<code>frameRate()</code>を使います。<code>draw()</code>が一回実行されたときを一つのフレームとして考えると、フレーム・レートは一秒あたり何回<code>draw()</code>が呼ばれるかを示します。</p>

<pre><code class="language-prerender">// FrameCountOverwrite
textSize(50); // 文字を大きくする
fill(0);      // 文字を黒にする
frameRate(1); // フレームをゆっくり出す
background(255);

function draw() {
  text(frameCount, 10, 50);
}
</code></pre>

<p>今回はわかりやすくなりましたね。同じところに連続で１、２、３などの数字を表示しています。<code>frameCount</code>はプログラムが開始されてから表示されたフレーム数を表しています。結果として<code>draw()</code>の実行ごとに0から1ずつ増えた数が重ねて描画されます。</p>

<p>次は番号が重ならないようにしましょう。新しい番号を表示する前にキャンバスをクリアすることで、新しい番号がはっきり見えます。キャンバスをクリアするためにはbackground()を使います。background()には前と同様にRGBの形式で色を指定できます。</p>

<pre><code class="language-prerender">// FrameCount
textSize(50); // 文字を大きくする
fill(0);      // 文字を黒にする
frameRate(1); // フレームをゆっくり出す

function draw() {
  background(200);  // キャンバスをグレーに塗りつぶす
  text(frameCount, 10, 50);
}
</code></pre>

<p>この例で出てきた<code>frameCount</code>は変数といいます。他の変数の例をみてみましょう。</p>

<pre><code>var x = 0;
</code></pre>

<p><code>var</code>を使って新しい変数を作りました。変数を使って、アニメーションを作りましょう。以下のプログラムをヘルプから読み込みしましょう。</p>

<pre><code class="language-prerender">// VariableExample

var x = 0;

function draw() {
  background(255);
  ellipse(x, 50, 80, 80);
  x = x + 1;
  if (x &gt; width) {
    x = 0;
  }
}
</code></pre>

<p>この例では、<code>draw()</code>を実行のたびにx変数の値を１づつ増やします。<code>if</code>文を使って、右側にたどり着いたら左側にもどします。<code>if</code>文は「条件分岐」と呼ぶこともあります。</p>

<p><strong>問題３</strong>：draw()やframeCountまたは自分で作った変数を使って好きなように雪だるまのアニメーションを作りましょう。何か分からないことがあったら質問してください。</p>

<pre><code class="language-render">size(300, 300, &#34;2D&#34;);
frameRate(30);
var x = 150, y = 170;

function draw() {
  background(220);
  strokeWeight(5);
  stroke(255, 100, 100);
  ellipse(x, y+80, 100, 100);
  stroke(100, 255, 100);
  ellipse(x-10*cos(frameCount*5), y, 80, 80);
  stroke(100, 100, 255);
  ellipse(x+10*sin(frameCount*5), y-60, 60, 60);
}
</code></pre>

<p>できましたか？　ヘルプのStep３の最後に「表示」のボタンを押して、一つのアニメーションの例を見てみましょう。</p>

<pre><code class="language-hidden">// WavingColoredSnowman
size(300, 300, &#34;2D&#34;);
frameRate(30);
var x = 150, y = 170;

function draw() {
  background(220);
  strokeWeight(5);
  stroke(255, 100, 100);
  ellipse(x, y+80, 100, 100);
  stroke(100, 255, 100);
  ellipse(x-10*cos(frameCount*5), y, 80, 80);
  stroke(100, 100, 255);
  ellipse(x+10*sin(frameCount*5), y-60, 60, 60);
}
</code></pre>

<p>次は<a href="#ref-PJSStep4">ステップ4</a>へ。</p>

</div><div id="ref-PJSStep4" class="section"><h1>ステップ4: マウスの使い方</h1>

<p>ゲームを作るにはユーザーからの入力を処理する必要があります。まずはマウスを使ってみましょう。プログラムの実行中にマウスがキャンバスの中に入ると、変数 mouseX と mouseY にマウスの位置が設定されます。</p>

<pre><code class="language-prerender">// CircleFollowsMouse
function draw() {
  background(255);  // 白
  ellipse(mouseX, mouseY, 20, 20);
}
</code></pre>

<p>マウスをキャンバス内で動かしてみましょう。丸がマウスについてくるのがわかるでしょう。</p>

<p>ちなみに、Javascriptでは関数を定義する方法はいくつかあります。こちらのプログラムは前のプログラムと全く同じ意味です。</p>

<pre><code class="language-prerender">// CircleFollowsMouse
var draw = function() {
  background(255);  // 白
  ellipse(mouseX, mouseY, 20, 20);
};
</code></pre>

<p>では、ユーザーがマウスをクリックしたらキャンバスを黒くしてみましょう。
ユーザーがマウスをクリックしたことに反応するためには、<code>mousePressed()</code>関数を定義します。この関数は、マウスのボタンが押されたときに呼ばれます。次のプログラムを実行して、マウスをキャンバス内でクリックすると、一瞬だけキャンバスが黒くなります。</p>

<pre><code class="language-prerender">// ClickedTooShort
function draw() {
  background(255);  // 白
  ellipse(mouseX, mouseY, 20, 20);
  frameRate(10);
}

function mousePressed() {
  background(0);  // 黒
}
</code></pre>

<p>なぜキャンバスが黒のままにならないのでしょうか。それは、<code>draw()</code>関数が繰り返し実行され、<code>draw()</code>の中にキャンバスを白く塗りつぶす命令<code>background(255, 255, 255)</code>があるからです。</p>

<p>マウスをクリックした後、キャンバスを一瞬だけではなくずっと黒にするには、どうすればいいでしょうか。</p>

<p>ここで変数が役に立ちます。ただ前と違って、Processingの標準の変数ではなくて、自分で新しい変数を作ります。変数を作るには、var c = 255;のような文をプログラムに追加します。この = 255 は変数の値を指定しています。c は変数の名前です。マウスがクリックされたときに <code>mousePressed()</code> が呼ばれるので、その中で変数の値を変えることができます。</p>

<pre><code class="language-prerender">// ClickedBlack
var c = 255;

function draw() {
  background(c);
  ellipse(mouseX, mouseY, 20, 20);
  frameRate(10);
}

function mousePressed() {
  c = 0;
}
</code></pre>

<p>ここでは、プログラムの実行を始めた時に変数 c が作られて、最初の値は 255 になっています。変数の値が 255 なので、<code>background(c);</code> はキャンバスを白く塗りつぶします。ユーザがマウスをクリックすると、<code>mousePressed()</code> が呼ばれて、変数 c の値が 0 になります。その後は、<code>background(c);</code> という命令はキャンバスを黒く塗りつぶすことになります。</p>

<p><strong>問題4</strong>: 雪だるまをマウスと一緒に動かしてみましょう。</p>

<pre><code class="language-hidden">// SnowmanFollowsMouse
draw = function() {
  background(220);
  ellipse(mouseX, mouseY+80, 100, 100);
  ellipse(mouseX, mouseY, 80, 80);
  ellipse(mouseX, mouseY-60, 60, 60);
};
</code></pre>

<p>次は<a href="#ref-PJSStep5">ステップ5</a>へ。</p>

</div><div id="ref-PJSStep5" class="section"><h1>ステップ5: キーボードの使い方</h1>

<p>ゲーム機には普通マウスはついてないので、キーパッドで遊ぶことが多いでしょう。では、ゲーム機のようにキーボードを使って遊べるようにするにはどうすればいいでしょうか。</p>

<p>Processingでは、キーボードの使い方はマウスととても似ています。キーボードのボタンが押されるたびに <code>keyPressed()</code> 関数が呼ばれます。次の例を見ましょう。その関数の中で<code>keyCode</code> を参照すると、押されたキーが分かります。</p>

<pre><code class="language-prerender">var x = 50;

function draw() {
  background(220);
  ellipse(x, 50, 30, 30);
}

function keyPressed() {
  if (keyCode === LEFT) {
    x = x - 5;
  }
  if (keyCode === RIGHT) {
      x = x + 5;
  }
}
</code></pre>

<p>このプログラムでは丸を描いています。実行し、キャンバス内をクリックして、左右の矢印キーを押してみましょう。</p>

<p><strong>問題5</strong>: 雪だるまをキーボードの左右矢印キーで動かしてみましょう。</p>

<pre><code class="language-hidden">// SnowmanKeyboard
var x = 150;

function draw() {
  background(220);
  ellipse(x, 250, 100, 100);
  ellipse(x, 170, 80, 80);
  ellipse(x, 110, 60, 60);
}

function keyPressed() {
  if (keyCode === LEFT) {
    x = x - 5;
  }
  if (keyCode === RIGHT) {
      x = x + 5;
  }
}
</code></pre>

<p>次は<a href="#ref-PJSStep6">ステップ6</a>へ。</p>

</div><div id="ref-PJSStep6" class="section"><h1>ステップ6: シミュレーション</h1>

<p>ゲームのなかのオブジェクトは動きが現実と近いと現実と近いと遊びやすくなります。たとえば、重力で落ちるボールはどのようにプログラムで表現すればよいのでしょうか？これはシミュレーションを使って実装できます。ボールのシミュレーションには位置と速度が必要です。重力の場合は加速度は定数です。</p>

<pre><code class="language-prerender">// FallingBall
var y = 10;
var vy = 0;

function draw() {
  // シミュレーション
  y = y + vy;     // 縦位置
  vy = vy + 0.1;  // 加速
  // アニメーション
  background(220);
  ellipse(50, y, 30, 30);
}
</code></pre>

<p>ボールのシミュレーションに２つの変数を使います。<code>y</code>は縦方向の位置、<code>vy</code>は縦方向の速度を表しています。<code>draw()</code>は一秒に10回呼ばれ、毎回新しい位置と速度を計算します。シミュレーションの計算の後、キャンバスを書き直すことでアニメーションを実装します。</p>

<p>以上のシミュレーションではボールが一回キャンバスの下に落ちたらキャンバスから消えてしまいます。ボールをゲームから消えさせないようにキャンバスの端からバウンドさせることもできます。
プログラムの実行の世界では端というものが存在しないので、プログラムは「壁にぶつかったか」という条件を調べなければいけません。</p>

<pre><code class="language-prerender">// BouncingBall
var y = 10;
var vy = 0;

function draw() {
  y = y + vy;     // 縦位置
  vy = vy + 0.1;  // 加速
  if (y &gt; height) {  // 床に当たる条件
    y = height;
    vy = -6;
  }
  background(220);
  ellipse(50, y, 30, 30);
}
</code></pre>

<p>この例では、円が床に当たっているかどうかという条件を調べています。<code>y</code>軸は下向きなので、キャンバスの下の部分のY座標は<code>height</code>です。シミュレーションの計算の結果でボールが床に当たったかどうかの条件は <code>y &gt; height</code>で調べられます。</p>

<p>ボールが床に当たった時にボールに上向きの速度を与えれば、本物のボールのようにバウンドします。</p>

<p><strong>問題6:</strong> 雪だるまを飛ばせてみましょう。</p>

<pre><code class="language-hidden">// SnowmanBounce

var x = 150;
var y = height;
var vy = -2;

function draw() {
  y = y + vy;
  vy = vy + 0.1;
  if (y &gt; height) {
    y = height;
    vy = -5;
  }
  background(220);
  ellipse(x, y-50, 100, 100);
  ellipse(x, y-130, 80, 80);
  ellipse(x, y-190, 60, 60);
}

function keyPressed() {
  if (keyCode === LEFT) {
    x = x - 5;
  }
  if (keyCode === RIGHT) {
      x = x + 5;
  }
}
</code></pre>

<p>次は<a href="#ref-PJSStep7">ステプ7</a>へ。</p>

</div><div id="ref-PJSStep7" class="section"><h1>ステップ7: 画像と音</h1>

<p>以前はゲーム作り基本を学びましたが、 楽しいゲームを作るために画像や音が欠かせないものです。 簡単な画像や音のエフェクトの使い方を紹介します。</p>

<pre><code class="language-prerender">// BananaImage
imageMode(CENTER);
image(getImage(&#34;cc0/banana-200x113&#34;), 50, 50, 100, 67);
</code></pre>

<p><code>imageMode</code>は画像の写し方を設定します。 <code>CENTER</code>(中心)を設定すると座標の(x,y)の点に画像の中心が写します。 <code>CORNER</code>(角)を設定すると(x,y)の点に左上角が写します。</p>

<pre><code class="language-render">var img = getImage(&#34;cc0/baloon1-170x200.png&#34;);
size(300, 200, &#34;2D&#34;);
frameRate(1);
textSize(16);
fill(0);
textAlign(LEFT, TOP);
strokeWeight(5);
function draw() {
  background(220);
  fill(0);
  if (frameCount % 2 === 0) {
    imageMode(CENTER);
    image(img, width/2, height/2, 85, 100);
    text(&#34;imageMode(CENTER);&#34;, 2, 5);
  } else {
    imageMode(CORNER);
    image(img, width/2, height/2, 85, 100);
    text(&#34;imageMode(CORNER);&#34;, 2, 5);
  }
  point(width/2, height/2);
  text(&#34;(x,y)&#34;, width/2, height/2);
}
</code></pre>

<p>画像をいくつか用意しましたので、<a href="#ref-ImageLibrary">画像リスト</a>でご確認ください。</p>

<p>音の場合も、音のデータを用意する必要があります。<code>getSound()</code>を呼ぶことによって音のデータを用意します。用意されたデータを変数（ここでは<code>sound</code>）に保存しておき、適切なときに<code>playSound()</code>命令を使って再生します。音の場合は、再生に時間がかかりますが、その間もプログラムは実行し続ます。</p>

<pre><code class="language-prerender">// MeowExample
var sound = getSound(&#34;cc0/meow.ogg&#34;);
function mouseClicked() {
  playSound(sound);
}
function draw() {
  if (!sound.audio.paused) {
    background(220);
    fill(0); textSize(20);
    text(&#34;Meow&#34;, 5, 20);
  } else {
    background(220);
  }
}
</code></pre>

<p>音をいくつか用意しましたので、<a href="#ref-SoundLibrary">音のリスト</a>を見てください。</p>

<p>次は<a href="#ref-PJSStep8">ステップ8</a>へ。</p>

</div><div id="ref-PJSStep8" class="section"><h1>ステップ7: ゲームサンプル</h1>

<p>次のプログラムをサンプルとして使って自由自在ゲームを作ってみましょう。 以下に部分ごとに説明あります。</p>

<pre><code class="language-example">// RocketLandingExample

var fire = getImage(&#34;cc0/fire2-134x200&#34;);
var rocket = getImage(&#34;cc0/rocket-168x300&#34;);
var rocket_fire = getImage(&#34;cc0/rocket1-168x300&#34;);
var explosion = getSound(&#34;cc0/explosion.ogg&#34;);
var roar = getSound(&#34;cc0/roar.ogg&#34;);
var win = getSound(&#34;cc0/win.ogg&#34;);

var x;
var y;
var vy;

var burning = false;
var gameOver = false;

function initVars() {
  x = 100;
  y = 10;
  vy = 0;
  gameOver = false;
  burning = false;
}

frameRate(20);
imageMode(CENTER);
initVars();

function draw() {
  y = y + vy;
  vy = vy + 0.2;
  
  if (y &gt; height - 30) {
    if (abs(vy) &gt; 3) {
      background(200);
      image(fire, x, y-25, 65, 100);
      playSound(explosion);
    } else {
      playSound(win);
    }
    noLoop();
    gameOver = true;
    return;
  }
  
  background(100);
  if (burning) {
    image(rocket_fire, x, y, 34, 60);
    burning = false;
  } else {
    image(rocket, x, y, 34, 60);
  }
}

function burn() {
  burning = true;
  vy -= 2;
  playSound(roar);
}

function keyPressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}

function mousePressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}
</code></pre>

<p>以下はサンプルゲームの簡単な説明です。</p>

<p>まずは使う画像をロードします。</p>

<pre><code>var fire = getImage(&#34;cc0/fire2-134x200&#34;);
var rocket = getImage(&#34;cc0/rocket-168x300&#34;);
var rocket_fire = getImage(&#34;cc0/rocket1-168x300&#34;);
</code></pre>

<p>次は音を用意します。</p>

<pre><code>var explosion = getSound(&#34;cc0/explosion.ogg&#34;);
var roar = getSound(&#34;cc0/roar.ogg&#34;);
var win = getSound(&#34;cc0/win.ogg&#34;);
</code></pre>

<p>ゲームの状態を保つために変数を作ります。</p>

<pre><code>var x;
var y;
var vy;

var burning = false;
var gameOver = false;
</code></pre>

<p>プログラムの一度の実行で、何回もゲームできるようにしますので、ゲームを最初の状態に戻す関数を用意します。（初期化する関数といいます）。</p>

<pre><code>function initVars() {
  x = 100;
  y = 10;
  vy = 0;
  gameOver = false;
  burning = false;
}
</code></pre>

<p>プログラムの最初のところ、フレームレートと画像の表示方法を設定します。または、初期化の関数を呼びます。</p>

<pre><code>frameRate(20);
imageMode(CENTER);
initVars();
</code></pre>

<p>フレームごとに呼ばれる<code>draw()</code>関数の中でシミュレーションを行います。</p>

<pre><code>function draw() {
  y = y + vy;
  vy = vy + 0.2;
</code></pre>

<p>シミュレーションの後、ゲームが終わったかどうかを調べます。このゲームはロケットが着陸したらゲームが終わりますので、<code>y &gt; height-30</code>の条件をチェックします。ロケットの位置を中心の座標を使ってあらわしているので、y が height - (画像の高さの半分) の時に、ちょうどロケットの下がキャンバスの一番下と一致(つまりロケットが着陸)します。この例ではロケットの画像の高さが 60 なので、その半分を引いた <code>height - 30</code> と y を比較します。</p>

<pre><code>  if (y &gt; height - 30) {
    if (abs(vy) &gt; 3) {
      background(200);
      image(fire, x, y-25, 65, 100);
      playSound(explosion);
    } else {
      playSound(win);
    }
    noLoop();
    gameOver = true;
    return;
  }
</code></pre>

<p>着陸条件を満たしていたら、安全に着陸できたかどうかしらべます。速度が速すぎたら(<code>abs(vy) &gt; 3</code>), 着陸失敗として、ロケットが爆発するアニメーションを表示します。成功の場合も失敗の場合も、<code>noLoop()</code>を呼んでアニメ−ションを一旦止めます。なぜかというと、次のゲームが始まるまではアニメーションは必要ないからです。</p>

<p>まだ着陸していない場合(上の<code>y &gt; height - 30</code>の条件を満たしていない場合)は、アニメーションを行います。</p>

<pre><code>  background(100);
  if (burning) {
    image(rocket_fire, x, y, 34, 60);
    burning = false;
  } else {
    image(rocket, x, y, 34, 60);
  }
</code></pre>

<p>ここでは、burningの変数をチェックして、ロケットの画像は炎付きの画像を表示するか、炎なしの画像を表示するかを決めます。</p>

<p>ロケットのエンジンが掛かる場合のシミュレーションをする関数も作ります。</p>

<pre><code>function burn() {
  burning = true;
  vy -= 2;
  playSound(roar);
}
</code></pre>

<p>なぜ関数が必要なのかというと、マウスでもキーボードでもゲームできるようにしたいからです。</p>

<p>キーボードを使うためにkeyPressed()の関数を定義します。</p>

<pre><code>function keyPressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}
</code></pre>

<p>キーボードには２つの機能があります。ゲームが終わった状態であれば、ゲーム状態をイニシャライズして新しいゲームをスタートします。そのためにloop()を呼んでアニメーションも再開します。ゲームの最中の場合(<code>gameOver</code>は偽の場合)はエンジンを掛けるシミュレーションが呼ばれます(<code>burn();</code>)。</p>

<p>同じように、マウスがクリックされたら、同じ対応します。</p>

<pre><code>function mousePressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}
</code></pre>

<p>これでゲームの完成です。</p>

<p>他のゲームは<a href="#ref-Games">サンプルゲーム</a>にご参照ください。</p>

</div><div id="ref-Tools" class="section"><h1>ツール</h1>

<ul>
<li><a href="#ref-ShowAxes">軸を示す</a></li>
<li><a href="#ref-ShowCoordinates">座標を示す</a></li>
<li><a href="#ref-ColorTool">色を選ぶ</a></li>
<li><a href="#ref-RectangleTool">長方形を描く</a></li>
<li><a href="#ref-EllipseTool">楕円を描く</a></li>
<li><a href="#ref-keyCodes">keyCodeを調べる</a></li>
</ul>

</div><div id="ref-ShowAxes" class="section"><h1>ShowAxes</h1>

<p>このプログラムは軸をお見せします。</p>

<pre><code class="language-prerender">// CanvasAxes
function arrow(x1, y1, x2, y2) {
  line(x1, y1, x2, y2);
  var x = x2-x1;
  var y = y2-y1;
  var l = sqrt(x*x+y*y);
  x = x / l * 10;
  y = y / l * 10;
  var alpha = 45;
  line(x2, y2, x2 - x*cos(alpha) + y*sin(alpha), y2 - x*sin(alpha) - y*cos(alpha));
  line(x2, y2, x2 - x*cos(-alpha) + y*sin(-alpha), y2 - x*sin(-alpha) - y*cos(-alpha));
}

arrow(10, 20, 90, 20);
arrow(20, 10, 20, 90);
fill(0);
text(&#34;(0,0)&#34;, 1, 11);
text(&#34;x&#34;, 80, 37);
text(&#34;y&#34;, 30, 85);
</code></pre>

</div><div id="ref-ShowCoordinates" class="section"><h1>ShowCoordinates</h1>

<p>このプログラムは座標をお見せします。マウスをキャンバス内で動かしてみてください。</p>

<pre><code class="language-prerender">// ShowCoordinates
size(200, 200, &#34;2D&#34;);

function draw() {
  background(220);
  textSize(20);
  fill(0);
  text(&#34;(&#34;+mouseX+&#34;,&#34;+mouseY+&#34;)&#34;, 80, 110);
}
</code></pre>

</div><div id="ref-ColorTool" class="section"><h1>ColorTool</h1>

<p>マウスを動かじながら、色を選ぶ</p>

<pre><code class="language-prerender">// ColorsDemo2
function posToColor(x, y) {
  if (x &lt; width/2 &amp;&amp; y &lt; height/2) {
    return color((width/2-x)/width*512, (height/2-y)/height*512, 0);
  } else if (x &lt; width/2) {
    return color(220);
  } else if (y &lt; height/2) {
    return color(0, (height/2-y)/height*512, (x-width/2)/width*512);
  } else {
    return color((y-height/2)/height*512, 0, (x-width/2)/width*512);
  }
}

size(300, 300, &#34;2D&#34;);
for (var x = 0; x &lt; width; x++) {
  for (var y = 0; y &lt; height; y++) {
    set(x, y, posToColor(x, y));
  }
}

fill(0);
textSize(height/20);
text(&#34;(255,0,0)&#34;, 5, height/2-5);
text(&#34;(255,255,0)&#34;, 5, 20);
textAlign(RIGHT, TOP);
text(&#34;(0,255,255)&#34;, width-5, 2);
textAlign(CENTER, TOP);
text(&#34;(0,255,0)&#34;, width/2, 2);
textAlign(LEFT, BASELINE);
fill(255);
text(&#34;(0,0,0)&#34;, width/2+2, height/2-2);
textAlign(RIGHT, BASELINE);
text(&#34;(0,0,255)&#34;, width-2, height/2);
fill(0);
textAlign(LEFT, BOTTOM);
text(&#34;(255,0,0)&#34;, width/2+2, height-2);
textAlign(RIGHT, BOTTOM);
text(&#34;(255,0,255)&#34;, width-2, height-2);

function draw() {
  var c = posToColor(mouseX, mouseY);
  noStroke();
  fill(c);
  rect(width/10, 6*height/10, 3*width/10, 3*height/10);
  fill(250);
  rect(width/10, 9*height/10, 3*width/10, height/15);
  fill(0);
  textSize(height/27);
  textAlign(LEFT, BASELINE);
  text(&#34;color(&#34;+red(c)+&#34;,&#34;+green(c)+&#34;,&#34;+blue(c)+&#34;)&#34;, width/10, height*19/20);
}
</code></pre>

</div><div id="ref-EllipseTool" class="section"><h1>EllipseTool</h1>

<p>このプログラムは楕円を書く命令をお見せします。キャンバス内でマウス・ドラッグしてみてください。</p>

<pre><code class="language-prerender">// EllipseTool
size(200, 200, &#34;2D&#34;);

var x1, y1, x2, y2;
var pressed = false;

function draw() {
  background(220);
  if (pressed) {
    x2 = mouseX;
    y2 = mouseY;
  }
  if (x2 !== x1) {
    fill(255);
    ellipse(x1, y1, (x2-x1)*2, (y2-y1)*2);
  }
  textSize(18);
  fill(0);
  text(&#34;ellipse(&#34;+x1+&#34;,&#34;+y1+&#34;,&#34;+((x2-x1)*2)+&#34;,&#34;+((y2-y1)*2)+&#34;)&#34;, 10, height-10);
}

function mousePressed() {
  if (!pressed) {
    x1 = mouseX;
    y1 = mouseY;
    pressed = true;
  }
}

function mouseReleased() {
  if (pressed) {
    x2 = mouseX;
    y2 = mouseY;
    pressed = false;
  }
}
</code></pre>

</div><div id="ref-RectangleTool" class="section"><h1>RectangleTool</h1>

<p>このプログラムは長方形を書く命令をお見せします。キャンバス内でマウス・ドラッグしてみてください。</p>

<pre><code class="language-prerender">// RectangleTool
size(200, 200, &#34;2D&#34;);

var x1, y1, x2, y2;
var pressed = false;

function draw() {
  background(220);
  if (pressed) {
    x2 = mouseX;
    y2 = mouseY;
  }
  if (x2 !== x1) {
    fill(255);
    rect(x1, y1, (x2-x1), (y2-y1));
  }
  textSize(20);
  fill(0);
  text(&#34;rect(&#34;+x1+&#34;,&#34;+y1+&#34;,&#34;+(x2-x1)+&#34;,&#34;+(y2-y1)+&#34;)&#34;, 10, height-10);
}

function mousePressed() {
  if (!pressed) {
    x1 = mouseX;
    y1 = mouseY;
    pressed = true;
  }
}

function mouseReleased() {
  if (pressed) {
    x2 = mouseX;
    y2 = mouseY;
    pressed = false;
  }
}
</code></pre>

</div><div id="ref-SoundLibrary" class="section"><h1>音のリスト</h1>

<pre><code class="language-prerender">// SoundExample
var sound = getSound(&#34;cc0/explosion.ogg&#34;);
function mousePressed() {
  playSound(sound);
}
</code></pre>

<ul>
<li><code>cc0/coin.ogg</code> <audio src="sounds/cc0/coin.ogg" controls=""></audio></li>
<li><code>cc0/tututun.ogg</code> <audio src="sounds/cc0/tututun.ogg" controls=""></audio></li>
<li><code>cc0/didin.ogg</code> <audio src="sounds/cc0/didin.ogg" controls=""></audio></li>
<li><code>cc0/rururun.ogg</code> <audio src="sounds/cc0/rururun.ogg" controls=""></audio></li>
<li><code>cc0/bells.ogg</code> <audio src="sounds/cc0/bells.ogg" controls=""></audio></li>
<li><code>cc0/strings.ogg</code> <audio src="sounds/cc0/strings.ogg" controls=""></audio></li>
<li><code>cc0/ugh.ogg</code> <audio src="sounds/cc0/ugh.ogg" controls=""></audio></li>
<li><code>cc0/bang.ogg</code> <audio src="sounds/cc0/bang.ogg" controls=""></audio></li>
<li><code>cc0/ding.ogg</code> <audio src="sounds/cc0/ding.ogg" controls=""></audio></li>
<li><code>cc0/cannon.ogg</code> <audio src="sounds/cc0/cannon.ogg" controls=""></audio></li>
<li><code>cc0/growl.ogg</code> <audio src="sounds/cc0/growl.ogg" controls=""></audio></li>
<li><code>cc0/explosion.ogg</code> <audio src="sounds/cc0/explosion.ogg" controls=""></audio></li>
<li><code>cc0/clicks.ogg</code> <audio src="sounds/cc0/clicks.ogg" controls=""></audio></li>
<li><code>cc0/fireworks.ogg</code> <audio src="sounds/cc0/fireworks.ogg" controls=""></audio></li>
<li><code>cc0/meow.ogg</code> <audio src="sounds/cc0/meow.ogg" controls=""></audio></li>
<li><code>cc0/dog.ogg</code> <audio src="sounds/cc0/dog.ogg" controls=""></audio></li>
<li><code>cc0/frog.ogg</code> <audio src="sounds/cc0/frog.ogg" controls=""></audio></li>
<li><code>cc0/roar.ogg</code> <audio src="sounds/cc0/roar.ogg" controls=""></audio></li>
<li><code>cc0/launch.ogg</code> <audio src="sounds/cc0/launch.ogg" controls=""></audio></li>
<li><code>cc0/shot.ogg</code> <audio src="sounds/cc0/shot.ogg" controls=""></audio></li>
<li><code>cc0/win.ogg</code> <audio src="sounds/cc0/win.ogg" controls=""></audio></li>
<li><code>sounds/rpg/battle-magic.mp3</code> <audio src="sounds/rpg/battle-magic.mp3" controls=""></audio></li>
<li><code>sounds/rpg/battle-spell.mp3</code> <audio src="sounds/rpg/battle-spell.mp3" controls=""></audio></li>
<li><code>sounds/rpg/giant-yah.mp3</code> <audio src="sounds/rpg/giant-yah.mp3" controls=""></audio></li>
<li><code>sounds/rpg/coin-jingle.mp3</code> <audio src="sounds/rpg/coin-jingle.mp3" controls=""></audio></li>
<li><code>sounds/rpg/hit-thud.mp3</code> <audio src="sounds/rpg/hit-thud.mp3" controls=""></audio></li>
<li><code>sounds/rpg/hit-whack.mp3</code> <audio src="sounds/rpg/hit-whack.mp3" controls=""></audio></li>
<li><code>sounds/rpg/battle-swing.mp3</code> <audio src="sounds/rpg/battle-swing.mp3" controls=""></audio></li>
<li><code>sounds/rpg/metal-chime.mp3</code> <audio src="sounds/rpg/metal-chime.mp3" controls=""></audio></li>
<li><code>sounds/rpg/water-slosh.mp3</code> <audio src="sounds/rpg/water-slosh.mp3" controls=""></audio></li>
<li><code>sounds/rpg/hit-clop.mp3</code> <audio src="sounds/rpg/hit-clop.mp3" controls=""></audio></li>
<li><code>sounds/rpg/metal-clink.mp3</code> <audio src="sounds/rpg/metal-clink.mp3" controls=""></audio></li>
<li><code>sounds/rpg/step-heavy.mp3</code> <audio src="sounds/rpg/step-heavy.mp3" controls=""></audio></li>
<li><code>sounds/rpg/water-bubble.mp3</code> <audio src="sounds/rpg/water-bubble.mp3" controls=""></audio></li>
<li><code>sounds/rpg/door-open.mp3</code> <audio src="sounds/rpg/door-open.mp3" controls=""></audio></li>
<li><code>sounds/rpg/hit-splat.mp3</code> <audio src="sounds/rpg/hit-splat.mp3" controls=""></audio></li>
<li><code>sounds/rpg/giant-no.mp3</code> <audio src="sounds/rpg/giant-no.mp3" controls=""></audio></li>
<li><code>sounds/rpg/giant-hyah.mp3</code> <audio src="sounds/rpg/giant-hyah.mp3" controls=""></audio></li>
<li><code>sounds/retro/whistle2.mp3</code> <audio src="sounds/retro/whistle2.mp3" controls=""></audio></li>
<li><code>sounds/retro/hit1.mp3</code> <audio src="sounds/retro/hit1.mp3" controls=""></audio></li>
<li><code>sounds/retro/thruster-short.mp3</code> <audio src="sounds/retro/thruster-short.mp3" controls=""></audio></li>
<li><code>sounds/retro/jump1.mp3</code> <audio src="sounds/retro/jump1.mp3" controls=""></audio></li>
<li><code>sounds/retro/whistle1.mp3</code> <audio src="sounds/retro/whistle1.mp3" controls=""></audio></li>
<li><code>sounds/retro/hit2.mp3</code> <audio src="sounds/retro/hit2.mp3" controls=""></audio></li>
<li><code>sounds/retro/laser2.mp3</code> <audio src="sounds/retro/laser2.mp3" controls=""></audio></li>
<li><code>sounds/retro/boom2.mp3</code> <audio src="sounds/retro/boom2.mp3" controls=""></audio></li>
<li><code>sounds/retro/coin.mp3</code> <audio src="sounds/retro/coin.mp3" controls=""></audio></li>
<li><code>sounds/retro/laser1.mp3</code> <audio src="sounds/retro/laser1.mp3" controls=""></audio></li>
<li><code>sounds/retro/laser4.mp3</code> <audio src="sounds/retro/laser4.mp3" controls=""></audio></li>
<li><code>sounds/retro/jump2.mp3</code> <audio src="sounds/retro/jump2.mp3" controls=""></audio></li>
<li><code>sounds/retro/rumble.mp3</code> <audio src="sounds/retro/rumble.mp3" controls=""></audio></li>
<li><code>sounds/retro/laser3.mp3</code> <audio src="sounds/retro/laser3.mp3" controls=""></audio></li>
<li><code>sounds/retro/thruster-long.mp3</code> <audio src="sounds/retro/thruster-long.mp3" controls=""></audio></li>
<li><code>sounds/retro/boom1.mp3</code> <audio src="sounds/retro/boom1.mp3" controls=""></audio></li>
</ul>

</div><div id="ref-ImageLibrary" class="section"><h1>画像リスト</h1>

<pre><code class="language-prerender">// ImageExample
imageMode(CENTER);
var img = getImage(&#34;cc0/baloon1-170x200.png&#34;);
image(img, 50, 50, 85, 100);
</code></pre>

<ul>
<li>cc0/baloon1-170x200.png
<img src="images/cc0/baloon1-170x200.png" alt="cc0/baloon1-170x200.png"/></li>
<li>cc0/baloon2-158x200.png
<img src="images/cc0/baloon2-158x200.png" alt="cc0/baloon2-158x200.png"/></li>
<li>cc0/banana-200x113.png
<img src="images/cc0/banana-200x113.png" alt="cc0/banana-200x113.png"/></li>
<li>cc0/baseball-200x171.png
<img src="images/cc0/baseball-200x171.png" alt="cc0/baseball-200x171.png"/></li>
<li>cc0/cat1-200x134.png
<img src="images/cc0/cat1-200x134.png" alt="cc0/cat1-200x134.png"/></li>
<li>cc0/cat2-185x200.png
<img src="images/cc0/cat2-185x200.png" alt="cc0/cat2-185x200.png"/></li>
<li>cc0/cat3-134x200.png
<img src="images/cc0/cat3-134x200.png" alt="cc0/cat3-134x200.png"/></li>
<li>cc0/dog1-200x188.png
<img src="images/cc0/dog1-200x188.png" alt="cc0/dog1-200x188.png"/></li>
<li>cc0/dog2-180x200.png
<img src="images/cc0/dog2-180x200.png" alt="cc0/dog2-180x200.png"/></li>
<li>cc0/dog3-179x200.png
<img src="images/cc0/dog3-179x200.png" alt="cc0/dog3-179x200.png"/></li>
<li>cc0/face1-150x200.png
<img src="images/cc0/face1-150x200.png" alt="cc0/face1-150x200.png"/></li>
<li>cc0/face2-171x200.png
<img src="images/cc0/face2-171x200.png" alt="cc0/face2-171x200.png"/></li>
<li>cc0/face3-188x200.png
<img src="images/cc0/face3-188x200.png" alt="cc0/face3-188x200.png"/></li>
<li>cc0/face4-106x200.png
<img src="images/cc0/face4-106x200.png" alt="cc0/face4-106x200.png"/></li>
<li>cc0/face5-163x200.png
<img src="images/cc0/face5-163x200.png" alt="cc0/face5-163x200.png"/></li>
<li>cc0/face6-155x200.png
<img src="images/cc0/face6-155x200.png" alt="cc0/face6-155x200.png"/></li>
<li>cc0/fire1-200x123.png
<img src="images/cc0/fire1-200x123.png" alt="cc0/fire1-200x123.png"/></li>
<li>cc0/fire2-134x200.png
<img src="images/cc0/fire2-134x200.png" alt="cc0/fire2-134x200.png"/></li>
<li>cc0/football1-200x200.png
<img src="images/cc0/football1-200x200.png" alt="cc0/football1-200x200.png"/></li>
<li>cc0/football2-200x200.png
<img src="images/cc0/football2-200x200.png" alt="cc0/football2-200x200.png"/></li>
<li>cc0/kiwi-200x200.png
<img src="images/cc0/kiwi-200x200.png" alt="cc0/kiwi-200x200.png"/></li>
<li>cc0/rose-200x161.png
<img src="images/cc0/rose-200x161.png" alt="cc0/rose-200x161.png"/></li>
<li>cc0/rocket-168x300.png
<img src="images/cc0/rocket-168x300.png" alt="cc0/rocket-168x300.png"/></li>
<li>cc0/rocket1-168x300.png
<img src="images/cc0/rocket1-168x300.png" alt="cc0/rocket1-168x300.png"/></li>
<li>cc0/smoke-200x195.png
<img src="images/cc0/smoke-200x195.png" alt="cc0/smoke-200x195.png"/></li>
<li>cc0/sunflower-130x200.png
<img src="images/cc0/sunflower-130x200.png" alt="cc0/sunflower-130x200.png"/></li>
<li>cc0/tennisball-200x197.png
<img src="images/cc0/tennisball-200x197.png" alt="cc0/tennisball-200x197.png"/></li>
<li>cc0/Walker44.png <img src="images/cc0/Walker44.png" alt="cc0/Walker44.png"/></li>
<li>cc0/fuzzy-white-64x64.png
<img src="images/cc0/fuzzy-white-64x64.png" alt="cc0/fuzzy-white-64x64.png"/></li>
<li>cc0/fuzzy-black-64x64.png
<img src="images/cc0/fuzzy-black-64x64.png" alt="cc0/fuzzy-black-64x64.png"/></li>
<li>seasonal/xmas-ornament-boat.png <img src="images/seasonal/xmas-ornament-boat.png" alt="seasonal/xmas-ornament-boat.png"/></li>
<li>seasonal/hannukah-dreidel.png <img src="images/seasonal/hannukah-dreidel.png" alt="seasonal/hannukah-dreidel.png"/></li>
<li>seasonal/gingerbread-house.png <img src="images/seasonal/gingerbread-house.png" alt="seasonal/gingerbread-house.png"/></li>
<li>seasonal/fireworks-2015.png <img src="images/seasonal/fireworks-2015.png" alt="seasonal/fireworks-2015.png"/></li>
<li>seasonal/xmas-cookies.png <img src="images/seasonal/xmas-cookies.png" alt="seasonal/xmas-cookies.png"/></li>
<li>seasonal/hannukah-menorah.png <img src="images/seasonal/hannukah-menorah.png" alt="seasonal/hannukah-menorah.png"/></li>
<li>seasonal/xmas-scene-holly-border.png <img src="images/seasonal/xmas-scene-holly-border.png" alt="seasonal/xmas-scene-holly-border.png"/></li>
<li>seasonal/fireworks-scattered.png <img src="images/seasonal/fireworks-scattered.png" alt="seasonal/fireworks-scattered.png"/></li>
<li>seasonal/gingerbread-houses.png <img src="images/seasonal/gingerbread-houses.png" alt="seasonal/gingerbread-houses.png"/></li>
<li>seasonal/penguin-with-presents.png <img src="images/seasonal/penguin-with-presents.png" alt="seasonal/penguin-with-presents.png"/></li>
<li>seasonal/fireworks-over-harbor.png <img src="images/seasonal/fireworks-over-harbor.png" alt="seasonal/fireworks-over-harbor.png"/></li>
<li>seasonal/snow-crystal3.png <img src="images/seasonal/snow-crystal3.png" alt="seasonal/snow-crystal3.png"/></li>
<li>seasonal/fireworks-in-sky.png <img src="images/seasonal/fireworks-in-sky.png" alt="seasonal/fireworks-in-sky.png"/></li>
<li>seasonal/xmas-tree.png <img src="images/seasonal/xmas-tree.png" alt="seasonal/xmas-tree.png"/></li>
<li>seasonal/disco-ball.png <img src="images/seasonal/disco-ball.png" alt="seasonal/disco-ball.png"/></li>
<li>seasonal/xmas-wreath.png <img src="images/seasonal/xmas-wreath.png" alt="seasonal/xmas-wreath.png"/></li>
<li>seasonal/snownoes.png <img src="images/seasonal/snownoes.png" alt="seasonal/snownoes.png"/></li>
<li>seasonal/xmas-tree-with-presents.png <img src="images/seasonal/xmas-tree-with-presents.png" alt="seasonal/xmas-tree-with-presents.png"/></li>
<li>seasonal/stocking-empty.png <img src="images/seasonal/stocking-empty.png" alt="seasonal/stocking-empty.png"/></li>
<li>seasonal/xmas-ornaments.png <img src="images/seasonal/xmas-ornaments.png" alt="seasonal/xmas-ornaments.png"/></li>
<li>seasonal/father-winston.png <img src="images/seasonal/father-winston.png" alt="seasonal/father-winston.png"/></li>
<li>seasonal/reindeer.png <img src="images/seasonal/reindeer.png" alt="seasonal/reindeer.png"/></li>
<li>seasonal/xmas-ornament-on-tree.png <img src="images/seasonal/xmas-ornament-on-tree.png" alt="seasonal/xmas-ornament-on-tree.png"/></li>
<li>seasonal/hopper-partying.png <img src="images/seasonal/hopper-partying.png" alt="seasonal/hopper-partying.png"/></li>
<li>seasonal/gingerbread-family.png <img src="images/seasonal/gingerbread-family.png" alt="seasonal/gingerbread-family.png"/></li>
<li>seasonal/reindeer-with-hat.png <img src="images/seasonal/reindeer-with-hat.png" alt="seasonal/reindeer-with-hat.png"/></li>
<li>seasonal/hopper-elfer.png <img src="images/seasonal/hopper-elfer.png" alt="seasonal/hopper-elfer.png"/></li>
<li>seasonal/gingerbread-man.png <img src="images/seasonal/gingerbread-man.png" alt="seasonal/gingerbread-man.png"/></li>
<li>seasonal/hopper-reindeer.png <img src="images/seasonal/hopper-reindeer.png" alt="seasonal/hopper-reindeer.png"/></li>
<li>seasonal/snow-crystal1.png <img src="images/seasonal/snow-crystal1.png" alt="seasonal/snow-crystal1.png"/></li>
<li>seasonal/snowy-slope-with-trees.png <img src="images/seasonal/snowy-slope-with-trees.png" alt="seasonal/snowy-slope-with-trees.png"/></li>
<li>seasonal/xmas-presents.png <img src="images/seasonal/xmas-presents.png" alt="seasonal/xmas-presents.png"/></li>
<li>seasonal/snowman.png <img src="images/seasonal/snowman.png" alt="seasonal/snowman.png"/></li>
<li>seasonal/santa-with-bag.png <img src="images/seasonal/santa-with-bag.png" alt="seasonal/santa-with-bag.png"/></li>
<li>seasonal/snow-crystal2.png <img src="images/seasonal/snow-crystal2.png" alt="seasonal/snow-crystal2.png"/></li>
<li>seasonal/red-nosed-winston.png <img src="images/seasonal/red-nosed-winston.png" alt="seasonal/red-nosed-winston.png"/></li>
<li>seasonal/house-with-lights.png <img src="images/seasonal/house-with-lights.png" alt="seasonal/house-with-lights.png"/></li>
<li>animals/cheetah.png <img src="images/animals/cheetah.png" alt="animals/cheetah.png"/></li>
<li>animals/birds<em>rainbow-lorakeets.png ![animals/birds</em>rainbow-lorakeets.png](images/animals/birds_rainbow-lorakeets.png)</li>
<li>animals/butterfly<em>monarch.png ![animals/butterfly</em>monarch.png](images/animals/butterfly_monarch.png)</li>
<li>animals/sleeping-puppy.png <img src="images/animals/sleeping-puppy.png" alt="animals/sleeping-puppy.png"/></li>
<li>animals/boxer-laying-down.png <img src="images/animals/boxer-laying-down.png" alt="animals/boxer-laying-down.png"/></li>
<li>animals/spider.png <img src="images/animals/spider.png" alt="animals/spider.png"/></li>
<li>animals/collies.png <img src="images/animals/collies.png" alt="animals/collies.png"/></li>
<li>animals/boxer-getting-tan.png <img src="images/animals/boxer-getting-tan.png" alt="animals/boxer-getting-tan.png"/></li>
<li>animals/penguins.png <img src="images/animals/penguins.png" alt="animals/penguins.png"/></li>
<li>animals/retriever.png <img src="images/animals/retriever.png" alt="animals/retriever.png"/></li>
<li>animals/fox.png <img src="images/animals/fox.png" alt="animals/fox.png"/></li>
<li>animals/boxer-wagging-tongue.png <img src="images/animals/boxer-wagging-tongue.png" alt="animals/boxer-wagging-tongue.png"/></li>
<li>animals/komodo-dragon.png <img src="images/animals/komodo-dragon.png" alt="animals/komodo-dragon.png"/></li>
<li>animals/butterfly.png <img src="images/animals/butterfly.png" alt="animals/butterfly.png"/></li>
<li>animals/dog<em>sleeping-puppy.png ![animals/dog</em>sleeping-puppy.png](images/animals/dog_sleeping-puppy.png)</li>
<li>animals/snake<em>green-tree-boa.png ![animals/snake</em>green-tree-boa.png](images/animals/snake_green-tree-boa.png)</li>
<li>animals/cat.png <img src="images/animals/cat.png" alt="animals/cat.png"/></li>
<li>animals/shark.png <img src="images/animals/shark.png" alt="animals/shark.png"/></li>
<li>animals/dogs<em>collies.png ![animals/dogs</em>collies.png](images/animals/dogs_collies.png)</li>
<li>animals/crocodiles.png <img src="images/animals/crocodiles.png" alt="animals/crocodiles.png"/></li>
<li>animals/kangaroos.png <img src="images/animals/kangaroos.png" alt="animals/kangaroos.png"/></li>
<li>animals/horse.png <img src="images/animals/horse.png" alt="animals/horse.png"/></li>
<li>animals/rabbit.png <img src="images/animals/rabbit.png" alt="animals/rabbit.png"/></li>
<li>landscapes/lotus-garden.png <img src="images/landscapes/lotus-garden.png" alt="landscapes/lotus-garden.png"/></li>
<li>landscapes/mountains-and-lake.png <img src="images/landscapes/mountains-and-lake.png" alt="landscapes/mountains-and-lake.png"/></li>
<li>landscapes/clouds-from-plane.png <img src="images/landscapes/clouds-from-plane.png" alt="landscapes/clouds-from-plane.png"/></li>
<li>landscapes/beach-waves-at-sunset2.png <img src="images/landscapes/beach-waves-at-sunset2.png" alt="landscapes/beach-waves-at-sunset2.png"/></li>
<li>landscapes/mountains-in-hawaii.png <img src="images/landscapes/mountains-in-hawaii.png" alt="landscapes/mountains-in-hawaii.png"/></li>
<li>landscapes/crop-circle.png <img src="images/landscapes/crop-circle.png" alt="landscapes/crop-circle.png"/></li>
<li>landscapes/mountains-sunset.png <img src="images/landscapes/mountains-sunset.png" alt="landscapes/mountains-sunset.png"/></li>
<li>landscapes/beach-waves-daytime.png <img src="images/landscapes/beach-waves-daytime.png" alt="landscapes/beach-waves-daytime.png"/></li>
<li>landscapes/beach.png <img src="images/landscapes/beach.png" alt="landscapes/beach.png"/></li>
<li>landscapes/beach-with-palm-trees.png <img src="images/landscapes/beach-with-palm-trees.png" alt="landscapes/beach-with-palm-trees.png"/></li>
<li>landscapes/beach-sunset.png <img src="images/landscapes/beach-sunset.png" alt="landscapes/beach-sunset.png"/></li>
<li>landscapes/fields-of-wine.png <img src="images/landscapes/fields-of-wine.png" alt="landscapes/fields-of-wine.png"/></li>
<li>landscapes/beach-at-dusk.png <img src="images/landscapes/beach-at-dusk.png" alt="landscapes/beach-at-dusk.png"/></li>
<li>landscapes/lava.png <img src="images/landscapes/lava.png" alt="landscapes/lava.png"/></li>
<li>landscapes/sand-dunes.png <img src="images/landscapes/sand-dunes.png" alt="landscapes/sand-dunes.png"/></li>
<li>landscapes/fields-of-grain.png <img src="images/landscapes/fields-of-grain.png" alt="landscapes/fields-of-grain.png"/></li>
<li>landscapes/lake-steam-rising.png <img src="images/landscapes/lake-steam-rising.png" alt="landscapes/lake-steam-rising.png"/></li>
<li>landscapes/waterfall<em>niagara-falls.png ![landscapes/waterfall</em>niagara-falls.png](images/landscapes/waterfall_niagara-falls.png)</li>
<li>landscapes/beach-waves-at-sunset.png <img src="images/landscapes/beach-waves-at-sunset.png" alt="landscapes/beach-waves-at-sunset.png"/></li>
<li>landscapes/beach-in-hawaii.png <img src="images/landscapes/beach-in-hawaii.png" alt="landscapes/beach-in-hawaii.png"/></li>
<li>landscapes/lake.png <img src="images/landscapes/lake.png" alt="landscapes/lake.png"/></li>
<li>food/grapes.png <img src="images/food/grapes.png" alt="food/grapes.png"/></li>
<li>food/strawberries.png <img src="images/food/strawberries.png" alt="food/strawberries.png"/></li>
<li>food/dumplings.png <img src="images/food/dumplings.png" alt="food/dumplings.png"/></li>
<li>food/potato-chips.png <img src="images/food/potato-chips.png" alt="food/potato-chips.png"/></li>
<li>food/ice-cream.png <img src="images/food/ice-cream.png" alt="food/ice-cream.png"/></li>
<li>food/mushroom.png <img src="images/food/mushroom.png" alt="food/mushroom.png"/></li>
<li>food/berries.png <img src="images/food/berries.png" alt="food/berries.png"/></li>
<li>food/cake.png <img src="images/food/cake.png" alt="food/cake.png"/></li>
<li>food/oysters.png <img src="images/food/oysters.png" alt="food/oysters.png"/></li>
<li>food/pasta.png <img src="images/food/pasta.png" alt="food/pasta.png"/></li>
<li>food/tomatoes.png <img src="images/food/tomatoes.png" alt="food/tomatoes.png"/></li>
<li>food/sushi.png <img src="images/food/sushi.png" alt="food/sushi.png"/></li>
<li>food/broccoli.png <img src="images/food/broccoli.png" alt="food/broccoli.png"/></li>
<li>food/chocolates.png <img src="images/food/chocolates.png" alt="food/chocolates.png"/></li>
<li>food/fish<em>grilled-snapper.png ![food/fish</em>grilled-snapper.png](images/food/fish_grilled-snapper.png)</li>
<li>food/croissant.png <img src="images/food/croissant.png" alt="food/croissant.png"/></li>
<li>food/brussels-sprouts.png <img src="images/food/brussels-sprouts.png" alt="food/brussels-sprouts.png"/></li>
<li>food/fruits.png <img src="images/food/fruits.png" alt="food/fruits.png"/></li>
<li>food/potatoes.png <img src="images/food/potatoes.png" alt="food/potatoes.png"/></li>
<li>food/shish-kebab.png <img src="images/food/shish-kebab.png" alt="food/shish-kebab.png"/></li>
<li>food/bananas.png <img src="images/food/bananas.png" alt="food/bananas.png"/></li>
<li>food/hamburger.png <img src="images/food/hamburger.png" alt="food/hamburger.png"/></li>
<li>food/coffee-beans.png <img src="images/food/coffee-beans.png" alt="food/coffee-beans.png"/></li>
</ul>

</div><div id="ref-workshopSep" class="section"><h1>Processing.js 夏期ワークショップ</h1>

<ul>
<li><a href="#ref-WhackACircle0">はじめに</a></li>
<li>Step 1: 円が１個

<ul>
<li><a href="#ref-WhackACircle11">Step 1.1: 円を描いてみる</a></li>
<li><a href="#ref-WhackACircle12">Step 1.2: コメントを書きましょう</a></li>
<li><a href="#ref-WhackACircle13">Step 1.3: 様々な色</a></li>
<li><a href="#ref-WhackACircle14">Step 1.4: ◯をランダムに表示</a></li>
<li><a href="#ref-WhackACircle15">Step 1.5: 円を「動かす」</a></li>
<li><a href="#ref-WhackACircle16">Step 1.6: クリックして文字を表示する</a></li>
<li><a href="#ref-WhackACircle17">Step 1.7: クリック回数を表示する</a></li>
<li><a href="#ref-WhackACircle18">Step 1.8: コードを整理しよう</a></li>
<li><a href="#ref-WhackACircle19">Step 1.9: 円をクリックしたらスコアを増やす</a></li>
</ul></li>
<li>Step 2: 円が 9 個

<ul>
<li><a href="#ref-WhackACircle21">Step 2.1: 9 個の円を一定の場所に表示する</a></li>
<li><a href="#ref-WhackACircle22">Step 2.2: 各円を表示するかどうかをランダムに決める</a></li>
<li><a href="#ref-WhackACircle23">Step 2.3: 課題</a></li>
</ul></li>
<li>迷路を右手法で解く

<ul>
<li><a href="#ref-Maze1">1. キャラクタを表示</a></li>
<li><a href="#ref-Maze2">2. キャラクターを動かす</a></li>
<li><a href="#ref-Maze3">3. 壁の検出</a></li>
<li><a href="#ref-Maze4">4. 右手法</a></li>
<li><a href="#ref-Maze5">5. ゴールの検出</a></li>
<li><a href="#ref-Maze6">6. 完成プログラム</a></li>
</ul></li>
<li>最短ルート探し

<ul>
<li><a href="#ref-LabyrinthBlank">1. 空迷路</a></li>
<li><a href="#ref-LabyrinthMapper">2. 地図作り</a></li>
<li><a href="#ref-LabyrinthSearch">3. 最短の道</a></li>
<li><a href="#ref-LabyrinthBacktrace">4. 道の作り直し</a></li>
<li><a href="#ref-LabyrinthSolver">5. 完成版</a></li>
</ul></li>
<li><a href="#ref-index">索引</a></li>
<li><a href="#ref-Demos">デモ</a></li>
<li><a href="#ref-Games">ゲーム</a></li>
</ul>

</div><div id="ref-WhackACircle0" class="section"><h1>はじめに</h1>

<p>今回は Scratch のようにブロックでコードを書くプログラミング言語ではなく、文字で書かれたプログラミング言語で、簡単なゲームを作ってみましょう。</p>

<p>このゲームは午前中に Scratch で作った「猫たたき」のように円が現れたり消えたりして、円をクリックできたら得点がもらえるゲームです。</p>

<pre><code class="language-render">// WhackACircle0
function circle(x, y, r) {
}
var width = 300;
var margin = 50;
var radius = 50;
var step = (width - 2*margin)/2;
function maru(col, row) {
  fill(0, 255, 0);
  stroke(255, 0, 0);
  strokeWeight(3);
  ellipse(margin + col*step, margin + row*step, radius, radius);
}

size(300, 300, &#34;2D&#34;);
background(255);
maru(0, 0);
maru(1, 0);
maru(1, 1);
maru(2, 1);
maru(0, 2);
maru(2, 2);
fill(0);
textSize(18);
text(&#34;スコア:2&#34;, 10, 20);

function draw() {
  exit();
}
</code></pre>

<h2>Processing って何？</h2>

<p>Processing は絵などを描けるプログラミング言語です。アプリ開発などで広く使われている Java
というプログラミング言語に近いので、Processing をマスターできたらあと一歩で Java でプログラムを書いて実際のエンジニアになれます。</p>

<h2>Processing で作る <strike>「猫たたき」</strike> 「◯たたき」</h2>

<p>では、本番に入って Processing のコードを書いてみましょう！</p>

<h2>Step 1: 円が１個</h2>

<p>最初のステップでは円１個だけをランダムに表示し、ユーザーがクリックできたらスコアを１増やします。</p>

<p><a href="#ref-WhackACircle11">Step 1.1: 円を描いてみる</a></p>

</div><div id="ref-WhackACircle11" class="section"><h1>Step 1.1: 円を描いてみる</h1>

<p><a href="#ref-WhackACircle0">前に戻る</a></p>

<p>まず円を描いてみましょう！以下のコードを入力して実行したら、円が描かれます。</p>

<pre><code class="language-prerender">// Circle
size(100, 100, &#34;2D&#34;);
ellipse(50, 50, 10, 10);
</code></pre>

<p>このプログラムには命令が２つ含まれています。最初の命令は <code>size(100, 100);</code> です。これはキャンバスの大きさを 100 × 100
にする命令です。これを指定して実行すると、四角いキャンバスが現れます。括弧の中に数字が 2
つ入っています。この数字を引数と呼びます。値を変えて実行すると、違うサイズのキャンバスが現れます。例えば、<code>size(500, 300);</code>
にすると、横長のキャンバスができたり、<code>size(200, 600);</code> にすると、縦長のキャンバスができます。</p>

<p>次の命令は <code>ellipse(50, 50, 10, 10);</code> です。これはキャンバスに円を描く命令です。この命令には 4 つの引数が必要です。最初の 2
つは円の中心点の位置を指定します。値を変えて実行し、円の位置を動かしてみましょう。最後の 2
つの引数は円の横と縦の直径を指定します。英語がわかる人は気づいたかもしれませんが、ellipse
という単語は円という意味ではなくて、楕円という意味です。円は必ず横と縦の直径が等しいですが、この命令で 2
つの値を違う大きさにすると円ではなく、楕円が描かれます。値を変えて実行してみましょう。</p>

<p>この 2 つの命令には行の最後に <code>;</code> <strong>セミコロン</strong>
があります。セミコロンは命令が終わったことを意味します。これがないと実行できたり、できなかったり、またはプログラムが思った通りに動かない場合があります。また、セミコロンを書き忘れると、赤い線が出てきます。この赤い線はコードの中でどこかで書き間違えているという意味なので、赤い線を見たら間違いを探してコードを修正してください。</p>

<p><img src="images/missing_semicolon.png" alt="Missing semicolon warning"/></p>

<p><a href="#ref-WhackACircle12">Step 1.2: コメントを書きましょう</a></p>

</div><div id="ref-WhackACircle12" class="section"><h1>Step 1.2: コメントを書きましょう</h1>

<p><a href="#ref-WhackACircle11">前に戻る</a></p>

<p>以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle11
// キャンバスの大きさを 300 x 300 にする
size(300, 300, &#34;2D&#34;);
// 中心座標が (150, 150)、直径が 10 の円を描く
ellipse(150, 150, 10, 10);
</code></pre>

<p>今回のコードには日本語の説明が入っています。これを<strong>コメント</strong>と呼びます。コメントに書かれた内容はコンピュータは実行しません。コメントは、コードを説明するためのもので、他人にコードを共有するときに相手の人が速く理解できるように記述します。誰かとコードを共有しなくてもコードが長くなると、自分でも１行１行の意味を忘れてしまうこともあるので、コメントをつける習慣を身につけましょう。</p>

<p><a href="#ref-WhackACircle13">Step 1.3: 様々な色</a></p>

</div><div id="ref-WhackACircle13" class="section"><h1>Step 1.3: 様々な色</h1>

<p><a href="#ref-WhackACircle12">前に戻る</a></p>

<p>色を変えてみましょう。以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle12
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗ります
background(255, 255, 255);
// 円の中身を緑色にする
fill(0, 255, 0);
// 円周を赤にする
stroke(255, 0, 0);
// 線の太さを 2 にする
strokeWeight(2);
// 中心座標が (150, 150)、直径が 40 の円を描く
ellipse(150, 150, 40, 40);
</code></pre>

<p>各命令の意味はコメントで説明されています。ここで注目してほしいのは色の指定方法です。すべての色に関する命令は 3
つの数値を必要とします。これはパソコンやTVで使用される画面の色の表示のしかたに由来します。画面で表示される色は３つの原色から表現されています。この原色は光の原色で、<strong>赤</strong>、<strong>緑</strong>、<strong>青</strong>で、RGB
(Red, Green, Blue) と呼ばれています。それぞれの値は0 から 255 まで指定できます。すべての値が 0 の場合は黒で、すべての値が 255
の場合は白になります。</p>

<p><img src="images/colors.png" alt="Color chart"/></p>

<p><a href="#ref-WhackACircle14">Step 1.4: ◯をランダムに表示</a></p>

</div><div id="ref-WhackACircle14" class="section"><h1>Step 1.4: ◯をランダムに表示</h1>

<p><a href="#ref-WhackACircle13">前に戻る</a></p>

<p>円をランダムな場所に表示します。以下のコードを入力して数回実行してみましょう。</p>

<pre><code class="language-example">// RandomCircle
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗る
background(255, 255, 255);
// 円の中身を緑色にする
fill(0, 255, 0);
// 円周を赤にする
stroke(255, 0, 0);
// 線の太さを 2 にする
strokeWeight(2);

// ランダムな座標を生成する
var x = random(0, 300);
var y = random(0, 300);

// 中心座標が (x, y)、直径が 40 の円を描く
ellipse(x, y, 40, 40);
</code></pre>

<p>実行される度に円の場所が変わることがわかります。そこで <code>var x = random(0, 300);</code>
という命令に注目してください。この命令は変数を定義します。変数はデータを一時的に保存するものです。Scratch
ではこのように変数を作って様々なブロックが現れますね。</p>

<p><img src="images/scratch_variable.png" alt="Scratch variable"/></p>

<p>変数を初めて使うときには、変数を「<strong>定義</strong>」して、変数の名前・型・初期値を決めます。名前と型は定義した後で変更できませんが、値は後から変更できます。</p>

<pre><code>var x = random(0, 300);
</code></pre>

<p>上記の文は、 <code>int</code>（整数）型の変数 <code>x</code> を定義し、初期値を <code>random(0, 300)</code>、つまり 0 から 300 までの乱数とします。<code>x</code> と
<code>y</code> の変数は円を描く命令に使われます。円の中心座標が今までの 150, 150 のかわりに <code>x</code>, <code>y</code> となり、命令が <code>ellipse(x, y,
40, 40);</code> になっています。</p>

<p><a href="#ref-WhackACircle15">Step 1.5: 円を「動かす」</a></p>

</div><div id="ref-WhackACircle15" class="section"><h1>Step 1.5: 円を「動かす」</h1>

<p><a href="#ref-WhackACircle14">前に戻る</a></p>

<p>今までは円を一回描くだけですが、次は円を繰り返しランダムな場所に描いてみます。以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle15
// 初期化・一回だけ実行される
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// 滑らかに描く
smooth();
// 1 秒間に 30 回描く
frameRate(30);

// ずっと実行される
function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);
  // 円の内部を緑色で塗る
  fill(0, 255, 0);
  // 円周を赤色で描く
  stroke(255, 0, 0);
  // 線の太さを 2 にする
  strokeWeight(2);

  // ランダムな座標を生成する
  var x = random(0, 300);
  var y = random(0, 300);

  // 中心座標が (x, y)、直径が 40 の円を描く
  ellipse(x, y, 40, 40);
}
</code></pre>

<p>実行すると、円が高速でランダムな場所で現れます。今回のプログラムには、<code>function draw() { ...
}</code> という書き方が出てきます。これらは<strong>メソッド</strong>と呼びます。メソッドは複数の命令をまとめて、１個の命令として使えるようにします。</p>

<p>Scratch では、各ブロック（例：ペンを下ろす）がメソッドだと考えても間違いではないでしょう。Processing
でメソッドを定義することは、Scratch でブロック定義を使用して他のブロックをまとめるのに似ています。次の例を見てみましょう。</p>

<p><img src="images/scratch_method.png" alt="Scratch method"/></p>

<p>Scratch と同様、Processing でも <code>size(300, 300);</code> などの命令がメソッドの呼び出しです。</p>

<p>Step 1.5 の Processing のプログラムでは、<code>setup</code> と <code>draw</code>
というメソッドを定義しています。これは特別なメソッドです。<code>setup</code> はプログラムが始まったらすぐに 1 回だけ実行されます。<code>draw</code> は
<code>setup</code> が実行されたあとに、ずっと実行されます。定義文の構成を説明します。最初の <code>void</code>
はこのメソッドを実行しても何の値も返さないという意味を宣言しています。値を返すメソッドもあり、<code>random</code> はその例の 1
つで指定された範囲からランダムな値を返します。</p>

<p>これから、値の返すメソッドを定義していきます。メソッド名のあとの括弧には何も入っていない <code>setup()</code>
のようなメソッドは引数を取りません。引数を取るメソッドも続きのステップで定義します。</p>

<p>さて、問題です。今のプログラムでは円が高速で動いています。もっとゆっくり動かすことができるでしょうか？コードとコメントを読んで、表示の頻度を 1 秒に 1
回に変えましょう。</p>

<p><a href="#ref-WhackACircle16">Step 1.6: クリックして文字を表示する</a></p>

</div><div id="ref-WhackACircle16" class="section"><h1>Step 1.6: クリックして文字を表示する</h1>

<p><a href="#ref-WhackACircle15">前に戻る</a></p>

<p>以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle16
size(300,300, &#34;2D&#34;);
framerate(1);

// マウスをクリックしたら実行される
function mouseClicked() {
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 30 にする
  textSize(30);
  // 座標 (150, 150) に「こんにちは」という文字を表示
  text(&#34;こんにちは&#34;, 150, 150);
}
</code></pre>

<p>上記のプログラムでは <code>mouseClicked()</code>
というメソッドが定義されています。これも特別なメソッドで、キャンバスにマウスでクリックした際にだけこのメソッドが実行されます。このようなきっかけを<strong>イベント</strong>と呼びます。そして、イベントが起こると実行されるメソッドを<strong>イベントハンドラ</strong>と呼びます。</p>

<p><a href="#ref-WhackACircle17">Step 1.7: クリック回数を表示する</a></p>

</div><div id="ref-WhackACircle17" class="section"><h1>Step 1.7: クリック回数を表示する</h1>

<p><a href="#ref-WhackACircle16">前に戻る</a></p>

<p>以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle17
var score = 0;

size(300,300, &#34;2D&#34;);
background(255, 255, 255);
frameRate(1);

function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 15 にする
  textSize(15);
  // 座標 (10, 20) にスコアを表示
  text(&#34;スコア: &#34; + str(score), 10, 20);
}

// マウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  // score の値を増やす
  score = score + 1;
}
</code></pre>

<p>上記のプログラムはメソッドの外で <code>score</code> という変数を定義しています。そして、マウスをクリックするたびにその値を 1
ずつ増やして表示します。値を増やす命令は、<code>score = score + 1</code>
と数学的にはありえない等式のようですが、これは等式ではなくて右の値を左の変数に代入する命令です。</p>

<p><a href="#ref-WhackACircle18">Step 1.8: コードを整理しよう</a></p>

</div><div id="ref-WhackACircle18" class="section"><h1>Step 1.8: コードを整理しよう</h1>

<p><a href="#ref-WhackACircle17">前に戻る</a></p>

<p>以下のコードを入力して実行してみましょう。</p>

<pre><code class="language-example">// WhackACircle18
// 円の中心の座標
var x;
var y;

// 円の半径
var radius = 20;

// スコアを初期化
var score = 0;

// 初期化・一回だけ実行される
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗ります
background(255, 255, 255);
// 滑らかに描く
smooth();
// 1 秒間、1 回描く
frameRate(1);

// 座標 (x, y) に円を描く
function drawCircle(x, y) {
  // 円の中身を緑色にする
  fill(0, 255, 0);
  // 円周を赤にする
  stroke(255, 0, 0);
  // 線の太さを 2 にする
  strokeWeight(2);
  // 中心座標が (x, y)、直径が radius * 2 の円を描く
  ellipse(x, y, radius * 2, radius * 2);
}

// スコアを表示
function drawScore() {
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 15 にする
  textSize(15);
  // スコアを文字にして、座標 (20, 40) に表示する
  text(&#34;スコア: &#34; + str(score), 20, 40);
}

// ずっと実行される
function draw() {
  // キャンバスを白で塗ります
  background(255, 255, 255);
  // ランダムな座標を生成する
  x = random(0, 300);
  y = random(0, 300);
  // 中心座標が (x, y) の円を描く
  drawCircle(x, y);
  // スコアの文字を表示する
  drawScore();
}

// マウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  // score の値を増やす
  score = score + 1;
}
</code></pre>

<p>上記は円を描くプログラムとスコアを表示するプログラムをあわせたものです。そこにコードをまとめるために <code>drawCircle</code> と <code>drawScore</code>
というメソッドを定義しています。この 2 つのメソッドの内容を <code>draw</code> に直接書くと、長くなって分かりにくくなります。そこで
2つの別々のメソッドにまとめています。</p>

<p>この状態ではどこをクリックしてもスコアが増えてしまいます。次は、円をクリックした場合にだけスコアが増えるようにコードを変更してみましょう。</p>

<p><a href="#ref-WhackACircle19">Step 1.9: 円をクリックしたらスコアを増やす</a></p>

</div><div id="ref-WhackACircle19" class="section"><h1>Step 1.9: 円をクリックしたらスコアを増やす</h1>

<p><a href="#ref-WhackACircle18">前に戻る</a></p>

<p>mouseClicked メソッドのコードを次のように書き換えて実行してみましょう。</p>

<pre><code>// ユーザーがマウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  // 円の中心点とマウスをクリックした場所との距離が radius より小さかったら
  if (dist(x, y, mouseX, mouseY) &lt; radius) {
    // score の値を増やす
    score = score + 1;
  }
}
</code></pre>

<p>ここでは条件文を使っています。<strong>条件文</strong>の構成は <code>if( ... ) { ... }</code>
です。括弧の中に条件を書きます。条件が満たされる場合、中括弧の中のコードが実行されます。</p>

<p>上記で使われている条件はコメントで説明されています。<code>dist()</code> メソッドは Processing でもともと定義されているメソッドで、 2
つの点の間の距離を計算します。</p>

<p>これで最初のステップが完成です。</p>

<p>今までの完成プログラムはこちらで確認できます。</p>

<pre><code class="language-hidden">// WhackACircle19
// 円の中心の座標
var x;
var y;

// 円の半径
var radius = 20;

// スコアを初期化
var score = 0;

// 初期化・一回だけ実行される
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗ります
background(255, 255, 255);
// 滑らかに描く
smooth();
// 1 秒間、1 回描く
frameRate(1);

// 座標 (x, y) に円を描く
function drawCircle(x, y) {
  // 円の中身を緑色にする
  fill(0, 255, 0);
  // 円周を赤にする
  stroke(255, 0, 0);
  // 線の太さを 2 にする
  strokeWeight(2);
  // 中心座標が (x, y)、直径が radius * 2 の円を描く
  ellipse(x, y, radius * 2, radius * 2);
}

// スコアを表示
function drawScore() {
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 15 にする
  textSize(15);
  // スコアを文字にして、座標 (20, 40) に表示する
  text(&#34;スコア: &#34; + str(score), 20, 40);
}

// ずっと実行される
function draw() {
  // キャンバスを白で塗ります
  background(255, 255, 255);
  // ランダムな座標を生成する
  x = random(0, 300);
  y = random(0, 300);
  // 中心座標が (x, y) の円を描く
  drawCircle(x, y);
  // スコアの文字を表示する
  drawScore();
}

// ユーザーがマウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  // 円の中心点とマウスをクリックした場所との距離が radius より小さかったら
  if (dist(x, y, mouseX, mouseY) &lt; radius) {
    // score の値を増やす
    score = score + 1;
  }
}
</code></pre>

<h2>Step 2: 円が 9 個</h2>

<p>円を９個に増やして、表示するかどうかをランダムに変えてみます。</p>

<p><a href="#ref-WhackACircle21">Step 2.1: 9 個の円を一定の場所に表示する</a></p>

</div><div id="ref-WhackACircle21" class="section"><h1>Step 2.1: 9 個の円を一定の場所に表示する</h1>

<p><a href="#ref-WhackACircle19">前に戻る</a></p>

<p>コードを次のように書き換えて実行してみましょう。 <code>circleX</code> と <code>circleY</code> は新しいメソッドです。古い <code>draw</code>
メソッドは消してください。</p>

<pre><code>// WhackACircle21
// i 番目の円の x 座標を返す (iは円の番号を表す0から8までの整数)
var circleX(i) {
  return (int)(i / 3) * 100 + 50;
}
// i 番目の円の y 座標を返す (iは円の番号を表す0から8までの整数)
var circleY(i) {
  return (i % 3) * 100 + 50;
}

// ずっと実行される
function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);

  // i を 0 から 8 まで繰り返す
  var i = 0;
  while (i &lt; 9) {
    // 座標 (circleX(i), circleY(i)) に円を描く
    drawCircle(circleX(i), circleY(i));
    // 次の円に移る
    i = i + 1;
  }

  // スコアの文字を表示する
  drawScore();
}
</code></pre>

<p>上記のコードは 9 個の円を描きます。円は 0 番から 8 番までの番号にします。各円の x 座標と y 座標はそれぞれ <code>circleX</code> と
<code>circleY</code> で計算します。<code>draw</code>
メソッド内では、<code>while</code>-ループを使って円を描きます。これは繰り返しを意味します。<code>while</code>-文の構成は <code>while( ... ) { ... }</code>
です。条件分岐の <code>if</code>
に近いですが、条件が満たされる限り中括弧のコードが永遠に実行されます。このようなプログラムを書くときには、ループからいつか出るように条件を設定する注意をしなければなりません。上記のコードでは、最初は
<code>i</code> を 0 に設定して、中括弧の最後のコードで 1 ずつ <code>i</code> を増やしています。</p>

<p>今までの完成プログラムはこちらで確認できます。</p>

<pre><code class="language-hidden">// WhackACircle21
// 円の中心の座標
var x;
var y;

// 円の半径
var radius = 20;

// スコアを初期化
var score = 0;

// 初期化・一回だけ実行される
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗ります
background(255, 255, 255);
// 滑らかに描く
smooth();
// 1 秒間、1 回描く
frameRate(1);


// 座標 (x, y) に円を描く
function drawCircle(x, y) {
  // 円の中身を緑色にする
  fill(0, 255, 0);
  // 円周を赤にする
  stroke(255, 0, 0);
  // 線の太さを 2 にする
  strokeWeight(2);
  // 中心座標が (x, y)、直径が radius * 2 の円を描く
  ellipse(x, y, radius * 2, radius * 2);
}

// スコアを表示
function drawScore() {
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 15 にする
  textSize(15);
  // スコアを文字にして、座標 (10, 20) に表示する
  text(&#34;スコア: &#34; + str(score), 10, 20);
}

// i 番目の円の x 座標を返す (iは円の番号を表す0から8までの整数)
var circleX(i) {
  return (int)(i / 3) * 100 + 50;
}
// i 番目の円の y 座標を返す (iは円の番号を表す0から8までの整数)
var circleY(i) {
  return (i % 3) * 100 + 50;
}

// ずっと実行される
function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);

  // i を 0 から 8 まで繰り返す
  var i = 0;
  while (i &lt; 9) {
    // 座標 (circleX(i), circleY(i)) に円を描く
    drawCircle(circleX(i), circleY(i));
    // 次の円に移る
    i = i + 1;
  }

  // スコアの文字を表示する
  drawScore();
}

// ユーザーがマウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  // 円の中心点とマウスをクリックした場所との距離が radius より小さかったら
  if (dist(x, y, mouseX, mouseY) &lt; radius) {
    // score の値を増やす
    score = score + 1;
  }
}
</code></pre>

<p><a href="#ref-WhackACircle22">Step 2.2: 各円を表示するかどうかをランダムに決める</a></p>

</div><div id="ref-WhackACircle22" class="section"><h1>Step 2.2: 各円を表示するかどうかをランダムに決める</h1>

<p><a href="#ref-WhackACircle21">前に戻る</a></p>

<p>コードを次のように書き換えて実行してみましょう。</p>

<pre><code>// WhackACircle22
// 円がそれぞれ現れているかを記憶する
boolean[] shown = new boolean[9];

// ずっと実行される
function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);

  // i を 0 から 8 まで繰り返す
  var i = 0;
  while (i &lt; 9) {
    // 50% の確率で表示される
    if (random(100) &lt; 50) {
      // i 番の円を表示する
      shown[i] = true;
      drawCircle(circleX(i), circleY(i));
    } else {
      // i 番の円を表示しない
      shown[i] = false;
    }
    i = i + 1;
  }

  // スコアの文字を表示する
  drawScore();
}

// マウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  var i = 0;
  while (i &lt; 9) {
    // 円の中心点とマウスをクリックした場所との距離が radius より小さかったら
    if (shown[i] &amp;&amp;
        dist(circleX(i), circleY(i), mouseX, mouseY) &lt; radius) {
      // score の値を増やす
      score = score + 1;
    }
    i = i + 1;
  }
}
</code></pre>

<p>上記のコードでは、各円が表示されているかを記憶する変数を用意します。メソッドの外の定義文は以下のようになっています。</p>

<pre><code>boolean[] shown = new boolean[9];
</code></pre>

<p>これは今まで違う変数の種類です。<code>boolean</code> は真理値型を指します。値が <code>true</code>（真） あるいは <code>false</code>（偽）の 2
つだけです。また<code>boolean</code> のあとの <code>[]</code> はこの変数を配列に定義する意味をします。配列は 1
つの変数で複数の値を記憶できるような変数です。そして、配列のサイズは初期値の <code>new boolean[9]</code> で指定しています。サイズは 9 で番号は 0
から 8 までになっています。</p>

<p>この配列は <code>draw</code> の中で値が決まります。そして、<code>mouseClicked</code> の中で値を使っています。</p>

<p>これでプログラムが完成です！実行して遊んでみてください。</p>

<pre><code class="language-hidden">// WhackACircle22
// 円の中心の座標
var x;
var y;

// 円の半径
var radius = 20;

// スコアを初期化
var score = 0;

// 初期化・一回だけ実行される
// キャンバスの大きさを 300 × 300 にする
size(300, 300, &#34;2D&#34;);
// キャンバスを白で塗ります
background(255, 255, 255);
// 滑らかに描く
smooth();
// 1 秒間、1 回描く
frameRate(1);

// 座標 (x, y) に円を描く
function drawCircle(x, y) {
  // 円の中身を緑色にする
  fill(0, 255, 0);
  // 円周を赤にする
  stroke(255, 0, 0);
  // 線の太さを 2 にする
  strokeWeight(2);
  // 中心座標が (x, y)、直径が radius * 2 の円を描く
  ellipse(x, y, radius * 2, radius * 2);
}

// スコアを表示
function drawScore() {
  // 文字の色を黒にする
  fill(0, 0, 0);
  // 文字の大きさを 15 にする
  textSize(15);
  // スコアを文字にして、座標 (10, 20) に表示する
  text(&#34;スコア: &#34; + str(score), 10, 20);
}

// i 番目の円の x 座標を返す (iは円の番号を表す0から8までの整数)
var circleX(i) {
  return (int)(i / 3) * 100 + 50;
}
// i 番目の円の y 座標を返す (iは円の番号を表す0から8までの整数)
var circleY(i) {
  return (i % 3) * 100 + 50;
}

// 円がそれぞれ現れているかを記憶する
boolean[] shown = new boolean[9];

// ずっと実行される
function draw() {
  // キャンバスを白で塗る
  background(255, 255, 255);

  // i を 0 から 8 まで繰り返す
  var i = 0;
  while (i &lt; 9) {
    // 50% の確率で表示される
    if (random(100) &lt; 50) {
      // i 番の円を表示する
      shown[i] = true;
      drawCircle(circleX(i), circleY(i));
    } else {
      // i 番の円を表示しない
      shown[i] = false;
    }
    i = i + 1;
  }

  // スコアの文字を表示する
  drawScore();
}

// マウスをクリックしたら実行されるイベントハンドラ
function mouseClicked() {
  var i = 0;
  while (i &lt; 9) {
    // 円の中心点とマウスをクリックした場所との距離が radius より小さかったら
    if (shown[i] &amp;&amp;
        dist(circleX(i), circleY(i), mouseX, mouseY) &lt; radius) {
      // score の値を増やす
      score = score + 1;
    }
    i = i + 1;
  }
}
</code></pre>

<p><a href="#ref-WhackACircle23">Step 2.3: 課題</a></p>

</div><div id="ref-WhackACircle23" class="section"><h1>Step 2.3: 課題</h1>

<p><a href="#ref-WhackACircle22">前に戻る</a></p>

<p>このプログラムはまだまだ改良できます。次の点を直す方法を考えて実装してみてください。</p>

<ul>
<li>円をクリックしてもすぐにスコアが更新されません。すぐにスコアが更新されるように改良してみましょう。</li>
<li>クリックして円に当たらなかった際、スコアをマイナスしてみましょう。</li>
<li>1 秒間に何回も円をクリックしてスコアを増やせてしまいます。円をクリックしたらその円がすぐに消えるなどの対策を実装してみましょう。</li>
</ul>

<p><a href="#ref-WhackACircle22">前に戻る</a></p>

</div><div id="ref-Maze1" class="section"><h1>1. キャラクターを表示</h1>

<p>まずは迷路を表示しましょう。 下にある「読み込む」ボタンを押してから画面の左上にある 「実行」ボタンをおしましょう。</p>

<pre><code class="language-example">// Maze1
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
</code></pre>

<p>そして、キャラクターを表示しましょう。キャラクターはマウスのカーソル のところに表示されます。Processing.jsでは画像はスクラッチのスプライトのよう
ではなく、スタンプのようなものです。なので、もともとの背景を壊さないように <a href="#ref-get">get()</a>を使って画像を保存して、あと背景を回復をしなければなりません。</p>

<pre><code class="language-example">// Maze1
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;
// キャラクターの座標。
var x = 176, y = 314;
var imgSave = null;
function draw() {
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  x = mouseX;
  y = mouseY;
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y, s, s);
}
</code></pre>

<p>次は<a href="#ref-Maze2">2. キャラクターを動かす</a></p>

</div><div id="ref-Maze2" class="section"><h1>2. キャラクターを動かす</h1>

<p><a href="#ref-Maze1">前に戻る</a></p>

<p>キャラクターを動かすために、次のコードを足してみましょう。</p>

<pre><code>// 進む方向
var dx = 0;
var dy = -1;

function draw() {  // この関数は繰り返し呼ばれている.
  image(imgWalker, x, y);
  x += dx;
  y += dy;
}
</code></pre>

<p>結果はこのようなスケッチになります。</p>

<pre><code class="language-hidden">// Maze2
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;
// キャラクターの座標
var x = 176, y = 314;

// 進む方向
var dx = 0;
var dy = -1;

var imgSave = null;
function draw() {  // この関数は繰り返し呼ばれている.
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  x += dx;
  y += dy;
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y);
}
</code></pre>

<p>キャラクターは壁を無視して動いてます。 <code>imgSave =
get(...)</code>や<code>image(imgSave,...)</code>をしなければ、キャラクターは壁に当たると壁を消して穴を開けてしまいます。
これは、実際には壁ではなくてただの背景画像が表示されているだけだからです。壁が実際にあるように見せるのが、プログラマの仕事です。</p>

<p>次は<a href="#ref-Maze3">3. 壁の検出</a></p>

</div><div id="ref-Maze3" class="section"><h1>3. 壁の検出</h1>

<p><a href="#ref-Maze2">前に戻る</a></p>

<p>壁を検出するには<a href="#ref-get">get()</a>関数を利用して、指定した位置のピクセルの色を調べます。<a href="[CENTER]">imageMode</a>の設定によって、キャラクターの位置はスタンプの中心を示すようになるので、キャラクターの進行方向の前の位置を調べましょう。</p>

<p>その前に、dx,
dyには常に０か１の値しか与えないようにします。たとえば、下は（０，１）、上は（０，−１）、右は（１，０）、左は（−１，０）です。最初の設定では上方向にしましょう。</p>

<pre><code>var dx = 0;
var dy = -1;
</code></pre>

<p>こうしておくと、 <code>(x+(s/2)*dx, y+(s/2)*dy)</code>
は常にキャラクターのちょうど前のピクセルを指すようになります。ここに３ピクセル足せば、キャラクターの少し前の位置になります。これが壁に当たったら<a href="#ref-noLoop">noLoop()</a>によってプログラムの実行を止めましょう。</p>

<pre><code>function wallAhead() {
  // キャラクターの３ピクセル前に調べよう.
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
　// 黒を検出しよう。
  return brightness(c) &lt; 50;
}

function draw() {
  ...
  if (wallAhead()) {
    noLoop(); // 実行を停止する
  }
  ...
}
</code></pre>

<p>スケッチこんな漢字になったでしょうか？</p>

<pre><code class="language-hidden">// Maze3
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;

// キャラクターの座標
var x = 176, y = 314;

// 進む方向
var dx = 0;
var dy = -1;

var imgSave = null;
function draw() {  // この関数は繰り返し呼ばれている.
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  if (wallAhead()) {
    noLoop(); // 実行を停止する
  }
  x += dx;
  y += dy;
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y);
}

var wallAhead() {
  // キャラクターの３ピクセル前に調べよう.
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
　// 黒を検出しよう。
  return brightness(c) &lt; 50;
}
</code></pre>

<p>止まる代わりにその場で回ってみましょう。</p>

<pre><code>function turnLeft() {
  var tmp = dx;
  dx = dy;
  dy = -tmp;
}

function draw() {
  ...
  if (wallAhead()) {
    turnLeft();
  }
  ...
}
</code></pre>

<p>ついでなので、前に動かす指示を関数としてまとめましょう。</p>

<pre><code>function moveForward() {
  x += dx;
  y += dy;
}

function draw() {
  ...
  if (wallAhead()) {
    turnLeft();
  }
  moveForward();
  ...
}
</code></pre>

<p>完成スケッチはこちらです。</p>

<pre><code class="language-hidden">// Maze3
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;

// キャラクターの座標
var x = 176, y = 314;

// 進む方向
var dx = 0;
var dy = -1;

var imgSave = null;
function draw() {  // この関数は繰り返し呼ばれている.
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  if (wallAhead()) {
    turnLeft();
  }
  moveForward();
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y);
}

var wallAhead() {
  // キャラクターの３ピクセル前に調べよう.
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
　// 黒を検出しよう。
  return brightness(c) &lt; 50;
}

function moveForward() {
  x += dx;
  y += dy;
}

function turnLeft() {
  var tmp = dx;
  dx = dy;
  dy = -tmp;
}
</code></pre>

<p>これだけでもキャラクターが少しは賢くみえてきましたが、動かしているとすぐに無限ループに入ってしまいます。</p>

<p>次は<a href="#ref-Maze4">4. 右手法</a></p>

</div><div id="ref-Maze4" class="section"><h1>4. 右手法</h1>

<p><a href="#ref-Maze3">前に戻る</a></p>

<p>右手法を実装するには、右側の壁を検出し、壁がない場合は右側に曲がることが必要になります。だいたいこのような感じでしょうか。</p>

<pre><code>function turnRight() {
  var tmp = dx;
  dx = -dy;
  dy = tmp;
}

function wallRight() {
  var rx = -dy;
  var ry = dx;
  var c = get(x + rx*(s/2+4), y + ry*(s/2+4));
  return brightness(c) &lt; 50;
}

function draw() {
  ...
  if (!wallRight()) {
    turnRight();
  } else if (wallAhead()) {
    turnLeft();
  }
  moveForward();
  ...
}
</code></pre>

<p>上のプログラムは一回右に曲がってしまうと、キャラクターが無限ループに入ってしまうため上手く動きません。原因は右側を検出する関数が1ピクセルしか確認していないため、キャラクター全体が曲がった先に入れないときにも
true を返してしまうからです。</p>

<p>キャラクターのサイズに合わせて検出してみましょう。</p>

<pre><code>function wallAhead() {
  var wallFound = false;
  var rx = -dy;
  var ry = dx;
  for (var i = -s/2-1; i &lt; s/2+1; i++) {
    var c = get(x+dx*(s/2+3)+rx*i, y+dy*(s/2+3)+ry*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

function wallRight() {
  var rx = -dy;
  var ry = dx;
  var wallFound = false;
  for (var i = -s/2-1; i &lt;= s/2+1; i++) {
    var c = get(x + rx*(s/2+3)+dx*i, y + ry*(s/2+3)+dy*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}
</code></pre>

<p>それでも他にも問題が残ってます。右に空き通路を検出すると、キャラクターはまた無限ループに入ってしまいます。今度の原因は、右に曲がったすぐ後に右側に壁がないとキャラクターがすぐにまた右に曲がってしまうことです。これを直すには、曲がってから数ピクセルはまっすぐに進む必要があります。</p>

<pre><code>function draw() {
  if (!wallRight()) {
    turnRight();
    moveForward();
    moveForward();
  } else if (wallAhead()) {
    turnLeft();
  }
  moveForward();
}
</code></pre>

<p>完成スケッチこちらです。</p>

<pre><code class="language-hidden">// Maze4
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;

// キャラクターの座標
var x = 176, y = 314;

// 進む方向
var dx = 0;
var dy = -1;

var imgSave = null;
function draw() {  // この関数は繰り返し呼ばれている.
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  if (!wallRight()) {
    turnRight();
    moveForward();
    moveForward();
  } else if (wallAhead()) {
    turnLeft();
  }
  moveForward();
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y);
}

var wallAhead() {
  var wallFound = false;
  var rx = -dy;
  var ry = dx;
  for (var i = -s/2-1; i &lt; s/2+1; i++) {
    var c = get(x+dx*(s/2+3)+rx*i, y+dy*(s/2+3)+ry*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

var wallRight() {
  var rx = -dy;
  var ry = dx;
  var wallFound = false;
  for (var i = -s/2-1; i &lt;= s/2+1; i++) {
    var c = get(x + rx*(s/2+3)+dx*i, y + ry*(s/2+3)+dy*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

function moveForward() {
  x += dx;
  y += dy;
}

function turnLeft() {
  var tmp = dx;
  dx = dy;
  dy = -tmp;
}

function turnRight() {
  var tmp = dx;
  dx = -dy;
  dy = tmp;
}
</code></pre>

<p>ここまでのプログラムで、キャラクターは迷路の中をうまく動くはずです。まだ問題がある場合、以下の点を確認しましょう。</p>

<ul>
<li><code>dx</code>, <code>dy</code>には-1/0/1の以外の値を与えない。</li>
<li>右側に空き通路を検出する関数はキャラクターが確実に入れる広さか確認する。</li>
</ul>

<p>次は<a href="#ref-Maze5">5. ゴールの判定</a></p>

</div><div id="ref-Maze5" class="section"><h1>5. ゴールの判定</h1>

<p><a href="#ref-Maze4">前に戻る</a></p>

<p>最後にゴールの判定をする機能を加えてみましょう。ゴールの判定は壁の検出に似ていますが、黒の代わりに緑か調べなければなりません。</p>

<pre><code>function reachedGoal() {
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
  return red(c) &lt; 50 &amp;&amp; green(c) &gt; 50;
}

function draw() {
  ...
  if (reachedGoal()) {
    fill(0,0,0);  // black.
    text(&#34;Finish!&#34;, x+s/2, y);
    exit();
  }
  ...
}
</code></pre>

<p>次は<a href="#ref-Maze6">6. 完成プログラム</a></p>

</div><div id="ref-Maze6" class="section"><h1>6. 完成プログラム</h1>

<p><a href="#ref-Maze5">前に戻る</a></p>

<p><strong>挑戦</strong>: 別の迷路を解いてみよう</p>

<p>別の迷路を解いてみましょう。2箇所の「labyrinth1.png」をに変えたら、別の迷路に挑戦できます。使用可能の迷路は</p>

<ul>
<li><code>labyrinth1.png</code></li>
<li><code>labyrinth2.png</code></li>
<li><code>labyrinth3.png</code></li>
<li><code>labyrinth4.png</code></li>
</ul>

<p>完成させたプログラムは全ての迷路を解けるでしょうか？</p>

<pre><code class="language-example">// Maze5
var imgLabyrinth = getImage(&#34;cc0/labyrinth1.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

size(360, 360, &#34;2D&#34;);  // キャンバスの大きさの設定
image(imgLabyrinth, 1, 1, 360, 360); // 迷路の表示
imageMode(CENTER);

// キャラクターの大きさ、ピクセル単位
var s = 44;

// キャラクターの座標
var x = 176, y = 314;

// 進む方向
var dx = 0;
var dy = -1;

var imgSave = null;
function draw() {  // この関数は繰り返し呼ばれている.
  if (imgSave != null) {
    image(imgSave, x, y, s, s);
  }
  if (reachedGoal()) {
    fill(0,0,0);  // black.
    text(&#34;Finish!&#34;, x+s/2, y);
    exit();
  }
  if (!wallRight() &amp;&amp; !wallAhead()) {
    turnRight();
    var hitWall = false;
    for (var i = 0; i &lt; 2; i++) {
      if (!wallAhead() &amp;&amp; !wallRight()) {
        moveForward(1);
      } else {
        hitWall = true;
        break;
      }
    }
    if (!hitWall) {
      //moveForward(-2);
      turnLeft();
    }
  } else if (wallAhead()) {
    turnLeft();
  }
  moveForward(1);
  imgSave = get(x-s/2, y-s/2, s, s);
  image(imgWalker, x, y);
}

var reachedGoal() {
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
  return red(c) &lt; 50 &amp;&amp; green(c) &gt; 50;
}

var wallAhead() {
  var wallFound = false;
  var rx = -dy;
  var ry = dx;
  for (var i = -s/2-1; i &lt; s/2+1; i++) {
    var c = get(x+dx*(s/2+3)+rx*i, y+dy*(s/2+3)+ry*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

var wallRight() {
  var rx = -dy;
  var ry = dx;
  var wallFound = false;
  for (var i = -s/2-1; i &lt;= s/2+1; i++) {
    var c = get(x + rx*(s/2+3)+dx*i, y + ry*(s/2+3)+dy*i);
    wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

function moveForward(c) {
  x += c*dx;
  y += c*dy;
}

function turnLeft() {
  var tmp = dx;
  dx = dy;
  dy = -tmp;
}

function turnRight() {
  var tmp = dx;
  dx = -dy;
  dy = tmp;
}
</code></pre>

</div><div id="ref-DrawFace" class="section"><h1>補足：顔を描く</h1>

<p>左側にあるプログラムを実行したら、右側にある実行キャンバスにさまざまな 絵や形状を描けます。位置を指定のために座標を使います。左上は(0,0)です。
座標の最初の数は左右を表して、最後の数は上下を表しています。</p>

<pre><code class="language-prerender">size(200, 200, &#34;2D&#34;);
fill(0);
textSize(10);

ellipse(0, 0, 10, 10);
text(&#34;(0, 0)&#34;, 10, 10);

ellipse(200, 0, 10, 10);
text(&#34;(200, 0)&#34;, 160, 10);

ellipse(0, 200, 10, 10);
text(&#34;(0, 200)&#34;, 10, 190);
</code></pre>

<p>では、丸を描きましょう。丸を描くために<code>ellipse()</code>という関数を使います。
<code>ellipse()</code>を呼ぶときは4つの数を指定します。最初2つの数は中心の座標を表します。
最後の2つの数は横幅と高さを表しています。例えば、縦の長い丸を描いてみましょう。 顔に似ているでしょうか？</p>

<pre><code class="language-prerender">size(200, 200, &#34;2D&#34;);
fill(255, 200, 180); // 肌色
ellipse(100, 100, 150, 180);
</code></pre>

<p>鼻を描くために三角を使いましょう。三角を描くために<code>triangle()</code>という関数を使います。
この関数を呼ぶときに数を6つを指定しなければなりません。それは三角の3つの点は各2つづつの座標です。</p>

<pre><code class="language-prerender">fill(100, 255, 100); // 緑
size(200, 200, &#34;2D&#34;);
triangle(100, 90, 90, 120, 110, 120);
</code></pre>

<p>口と目を前と同じように<code>ellipse()</code>を使いましょう。次の見本のプログラムに進む前に 自分で目と口を描いてみましょう。</p>

<pre><code class="language-prerender">size(200, 200, &#34;2D&#34;);
fill(255, 200, 180); // 肌色
ellipse(100, 100, 150, 180);  // 顔
fill(100, 255, 100); // 緑
triangle(100, 90, 90, 120, 110, 120); // 鼻
fill(0, 0, 150); // 青
ellipse(60, 75, 30, 5); // 左目
ellipse(140, 75, 30, 5); // 右目
fill(255, 130, 120); // 赤
ellipse(100, 160, 60, 15); // 口
</code></pre>

</div><div id="ref-Loop" class="section"><h1>補足：繰り返し（ループ）</h1>

<p>同じ命令を何回も繰り返すためにループを使います。</p>

<pre><code class="language-prerender">for (var i = 1; i &lt;= 5; i++) {　// 1から5まで数えます。
  text(str(i), 10, 10+i*10);
}
</code></pre>

<p>条件を調べることは「if」文でできます。</p>

<pre><code class="language-prerender">for (var i = 1; i &lt;= 5; i++) {　// 1から5まで数えます。
  if (i % 2 == 1) {  // 奇数かどうか調べます
    text(str(i), 10, 10+i*10);
  }
}
</code></pre>

</div><div id="ref-Events" class="section"><h1>補足：イベント</h1>

<p>プログラムの実行中でユーザの入力に対応するにはいくつかの方法ありますが、 こちらで<strong>イベント</strong>を紹介します。ユーザーはマウスクリックしたときに
<a href="#ref-mouseClicked">mouseClicked()</a>という関数が呼ばれます。</p>

<pre><code class="language-example">// マウスがクリックした時に実行されます。
function mouseClicked() {　
  // 長方形の中か外か判断する。
  if (60 &lt;= mouseX &amp;&amp; mouseX &lt;= 140 &amp;&amp;
      60 &lt;= mouseY &amp;&amp; mouseY &lt;= 140) {
    speak(&#34;ピンポン&#34;);
  } else {
    speak(&#34;ぶぶ&#34;);
  }
}

// 設定。実行の最初に実行されます。
size(200, 200, &#34;2D&#34;);   // キャンバスの大きさを設定する。
background(200);　// 灰色に塗る。
stroke(0);　　　　 // 筆色を黒にする。
rect(60, 60, 80, 80);  // 長方形を描く。
</code></pre>

<p>マウスイベントについてもっと詳しくは<a href="#ref-Mouse">マウス</a>に参考ください。</p>

</div><div id="ref-Mouse" class="section"><h1>マウス</h1>

<p>マウスの入力は<a href="#ref-Events">イベント</a>によって行う。イベントのリスト:</p>

<ul>
<li><a href="#ref-mouseClicked">mouseClicked()</a> マウスはクリックされたとき</li>
<li><a href="#ref-mousePressed">mousePressed()</a> マウスのボタンが押されたとき</li>
<li><a href="#ref-mouseReleased">mouseReleased()</a> マウスのボタンが話されたとき</li>
<li><a href="#ref-mouseMoved">mouseMoved()</a> マウスが動いたとき</li>
<li><a href="#ref-mouseDragged">mouseDragged()</a> マウスが押されたままに動いたとき</li>
<li><a href="#ref-mouseOver">mouseOver()</a> マウスのカーソルはキャンバスに入ったとき</li>
<li><a href="#ref-mouseOut">mouseOut()</a> マウスのカーソルがキャンバスから離れたとき</li>
<li><a href="#ref-mouseX">mouseX</a>, <a href="#ref-mouseY">mouseY</a> マウスのXとY座標</li>
<li><a href="#ref-mouseButton">mouseButton</a> マウスイベントの関数の中は押されたボタンを表す</li>
</ul>

<h2>参考</h2>

<ul>
<li><a href="#ref-draw">draw()</a></li>
<li><a href="#ref-noLoop">noLoop()</a></li>
<li><a href="#ref-loop">loop()</a></li>
</ul>

</div><div id="ref-draw" class="section"><h1>draw</h1>

<p>スケッチを実行すると、<code>setup()</code>関数が1回呼ばれた後、<code>draw()</code>関数が繰り返し呼ばれます。 <code>draw()</code>関数の中で画面を更新することでアニメーションを実現することができます。 <code>draw()</code>関数を1秒間に何回呼ぶかは<code>frameRate()</code>で設定できます。</p>

<pre><code class="language-prerender">// DrawExample
frameRate(1);  // 1秒に1回呼ぶ
fill(0);  // 描画色を黒に設定。
textSize(30);

function draw() {
  background(200);
  text(frameCount, 10, 30);
}
</code></pre>

<p>関連項目: <a href="#ref-frameRate">frameRate()</a>, <a href="#ref-frameCount">frameCount</a></p>

</div><div id="ref-frameRate" class="section"><h1>frameRate</h1>

<p><code>frameRate(x)</code>は<code>draw()</code>が呼ばれる頻度を設定します。 括弧の中には<code>draw()</code>関数を1秒間に何回呼ぶかを指定します。 たとえば、<code>frameRate(10)</code>を実行すると、<code>draw()</code>の実行が終わってから 次に<code>draw()</code>を呼ぶまで0.1秒待ちます。<code>frameRate(1)</code>では1秒待ちます。</p>

<pre><code class="language-prerender">// FrameRateExample
frameRate(1);  // 1秒に1回呼ぶ
fill(0);  // 描画色を黒に設定。
textSize(30);

function draw() {
  background(200);
  text(frameCount, 10, 30);
}

function mousePressed() {
    frameRate(5);
}

function mouseReleased() {
    frameRate(1);
}
</code></pre>

<p>関連項目: <a href="#ref-frameCount">frameCount</a>, <a href="#ref-draw">draw()</a>.</p>

</div><div id="ref-frameCount" class="section"><h1>frameCount</h1>

<p><code>frameCount</code>は<code>draw()</code>が呼ばれた回数です。</p>

<pre><code class="language-prerender">// FrameCountExample
frameRate(1);  // 1秒に1回呼ぶ
fill(0);  // 描画色を黒に設定。
textSize(30);

function draw() {
  background(200);
  text(frameCount, 10, 30);
}
</code></pre>

<p>関連項目: <a href="#ref-frameRate">frameRate()</a>, <a href="#ref-draw">draw()</a>.</p>

</div><div id="ref-width" class="section"><h1>width</h1>

<p><code>width</code>はキャンバスの横幅です。</p>

<pre><code class="language-prerender">// WidthAndHeightExample
fill(0);
textSize(15);
text(&#34;width: &#34; + width, 10, 50);
text(&#34;height: &#34; + height, 10, 80);
</code></pre>

<p>普段は約400ですが、環境によって違います。例えば、フルスクリーン(全画面)モードだと、画面の大きさによります。</p>

<p>関連項目: <a href="#ref-size">size()</a>, <a href="#ref-height">height</a></p>

</div><div id="ref-height" class="section"><h1>height</h1>

<p><code>height</code>はキャンバスの縦幅です。</p>

<pre><code class="language-prerender">// WidthAndHeightExample
fill(0);
textSize(15);
text(&#34;width: &#34; + width, 10, 50);
text(&#34;height: &#34; + height, 10, 80);
</code></pre>

<p>普段は約400ですが、環境によって違います。例えば、フルスクリーン(全画面)モードだと、画面の大きさによります。</p>

<p>関連項目: <a href="#ref-size">size()</a>, <a href="#ref-width">width</a></p>

</div><div id="ref-print" class="section"><h1>print</h1>

<p><code>print</code>はメッセージを表示します。メッセージはキャンバス内の下にでてきます。<code>println()</code>と違って、メッセージの後で改行しません。</p>

<p>呼び方:<code>print(message);</code></p>

<p>関連項目:<a href="#ref-println">println()</a>。</p>

</div><div id="ref-println" class="section"><h1>println</h1>

<p><code>println()</code>はメッセージを表示します。メッセージはキャンバス内の下にでてきます。<code>print()</code>と違って、メッセージの後で改行します。</p>

<p>呼び方:<code>println(message);</code></p>

<p>関連項目:<a href="#ref-print">print()</a>。</p>

</div><div id="ref-index" class="section"><h1>インデックス</h1>

<p>正式なProcessing.jsのマニュアルはこちら:
<a href="https://www.khanacademy.org/computer-programming/new/pjs#scratchpad-tabs" target="_blank">https://www.khanacademy.org/computer-programming/new/pjs#scratchpad-tabs</a>.</p>

<h2>実行</h2>

<ul>
<li><a href="#ref-draw">function draw() {…}</a> アニメーションのフレームを描くための関数</li>
<li><a href="#ref-noLoop">noLoop()</a> <code>draw()</code>の実行を停止。マウスやキーボードの関数は実行されます。</li>
<li><a href="#ref-exit">exit()</a> 実行を終了する</li>
</ul>

<h2>アニメーション</h2>

<ul>
<li><a href="#ref-noLoop">noLoop()</a> アニメーションの繰り返しを止める</li>
<li><a href="#ref-loop">loop()</a> アニメーションの繰り返しを再開する</li>
<li><a href="#ref-millis">millis()</a> 実行時間をミリ秒単位で返す</li>
<li><a href="#ref-frameRate">frameRate()</a> <code>draw()</code>の呼び方の頻度の設定</li>
<li><a href="#ref-frameCount">frameCount</a> <code>draw()</code>が何回呼ばれたかカウント</li>
</ul>

<h2>キャンバス</h2>

<ul>
<li><a href="#ref-background">background()</a> キャンバスを色で塗る</li>
<li><a href="#ref-size">size()</a> キャンバスの大きさを設定する</li>
<li><a href="#ref-width">width</a>, <a href="#ref-height">height</a> 横幅、縦幅</li>
<li><a href="#ref-dist">dist()</a> 2点間の距離を計算する</li>
<li><a href="#ref-copy">copy()</a> 画像の一部を別の位置にコピーする</li>
</ul>

<h2>図形</h2>

<ul>
<li><a href="#ref-ellipse">ellipse()</a> 楕円</li>
<li><a href="#ref-rect">rect()</a> 長方形</li>
<li><a href="#ref-triangle">triangle()</a> 三角形</li>
<li><a href="#ref-line">line()</a> 直線</li>
<li><a href="#ref-arc">arc()</a> 円弧</li>
<li><a href="#ref-point">point()</a> 点</li>
</ul>

<h2>筆の設定や色</h2>

<ul>
<li><a href="#ref-color">color()</a>は色を表す値を作る</li>
<li><a href="#ref-fill">fill()</a> 塗りつぶしの色を設定する</li>
<li><a href="#ref-stroke">stroke()</a>, <a href="#ref-noStroke">noStroke()</a> ペンの色を設定する</li>
<li><a href="#ref-strokeCap">strokeCap()</a> ペンの端の形を設定する</li>
<li><a href="#ref-strokeWeight">strokeWeight()</a> ペンの太さを設定する</li>
<li><a href="#ref-red">red()</a>, <a href="#ref-green">green()</a>, <a href="#ref-blue">blue()</a>, <a href="#ref-hue">hue()</a>, <a href="#ref-saturation">saturation()</a>, <a href="#ref-brightness">brightness()</a>, <a href="#ref-colorMode">colorMode()</a></li>
</ul>

<h2>画像</h2>

<ul>
<li><a href="#ref-image">image()</a> 画像を写す</li>
<li><a href="#ref-imageMode">imageMode()</a> 画像の写し方の設定</li>
<li><a href="#ref-getImage">getImage()</a>  画像データを読み込む</li>
<li><a href="#ref-get">get()</a> 画像データをキャンバスから抽出する</li>
</ul>

<h2>文字</h2>

<ul>
<li><a href="#ref-text">text()</a> 文字を表示する</li>
<li><a href="#ref-textSize">textSize()</a> 文字の大きさを設定する</li>
<li><a href="#ref-textAlign">textAlign()</a> 文字の写し方を設定する</li>
<li><a href="#ref-textFont">textFont()</a> 字体を設定する</li>
<li><a href="#ref-loadFont">loadFont()</a> 字体を読み込みする</li>
</ul>

<h2>スピーチ</h2>

<ul>
<li><a href="#ref-speak">speak()</a> 声で話す</li>
</ul>

<h2><a href="#ref-Mouse">マウス</a></h2>

<ul>
<li><a href="#ref-mouseClicked">mouseClicked()</a> マウスのボタンがクリックされたとき</li>
<li><a href="#ref-mouseDragged">mouseDragged()</a> マウスを押したまま動かしたときに呼ばれます</li>
<li><a href="#ref-mouseMoved">mouseMoved()</a> マウスカーソルを動かしたときに呼ばれます</li>
<li><a href="#ref-mousePressed">mousePressed()</a> マウスのボタンが押されたとき</li>
<li><a href="#ref-mouseReleased">mouseReleased()</a> マウスのボタンが離されたとき</li>
<li><a href="#ref-mouseOver">mouseOver()</a> マウスがキャンバス内に入ったとき</li>
<li><a href="#ref-mouseOut">mouseOut()</a> マウスがキャンバスの外に出たとき</li>
<li><a href="#ref-mouseX">mouseX</a>, <a href="#ref-mouseY">mouseY</a>, <a href="#ref-pmouseX">pmouseX</a>, <a href="#ref-pmouseY">pmouseY</a> マウスのX座標とY座標</li>
<li><a href="#ref-mouseButton">mouseButton</a> マウスイベント関数の中で押されたボタンを表す</li>
<li><a href="#ref-cursor">cursor()</a> マウスカーソルの形を変える</li>
</ul>

<h2>キーボード</h2>

<ul>
<li><a href="#ref-keyPressed">keyPressed()</a>, <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-keyTyped">keyTyped()</a> キーボードのイベント関数</li>
<li><a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyIsPressed">keyIsPressed</a> 押されたキーの変数</li>
<li><a href="#ref-keyCodes">keyCodes</a> キーコードの一覧</li>
</ul>

<h2>言語の基礎</h2>

<ul>
<li>条件付き実行

<ul>
<li><a href="#ref-if">if</a>, <a href="#ref-else">else</a></li>
</ul></li>
<li><a href="#ref-Loop">ループ</a>

<ul>
<li><a href="#ref-for">for</a>, <a href="#ref-while">while</a>, <a href="#ref-do">do</a></li>
<li><a href="#ref-continue">continue</a>, <a href="#ref-break">break</a></li>
</ul></li>
<li>switch文

<ul>
<li><a href="#ref-switch">switch</a>, <a href="#ref-case">case</a>, <a href="#ref-default">default</a></li>
</ul></li>
<li>クラス

<ul>
<li><a href="#ref-class">class</a>, <a href="#ref-this">this</a></li>
</ul></li>
<li><a href="#ref-final">final</a></li>
</ul>

<h2>定数</h2>

<ul>
<li><a href="#ref-PI">PI</a>, <a href="#ref-HALF_PI">HALF_PI</a>, <a href="#ref-QUARTER_PI">QUARTER_PI</a>, <a href="#ref-TWO_PI">TWO_PI</a>.</li>
</ul>

<h2>数学関数</h2>

<ul>
<li><a href="#ref-abs">abs()</a></li>
<li><a href="#ref-ceil">ceil()</a>, <a href="#ref-floor">floor()</a>, <a href="#ref-round">round()</a></li>
<li><a href="#ref-sin">sin()</a>, <a href="#ref-cos">cos()</a>, <a href="#ref-tan">tan()</a></li>
</ul>

</div><div id="ref-size" class="section"><h1>size</h1>

<p><code>size(x_size, y_size)</code>はキャンバスの大きさを定めます。スケッチの実行の最初に一回だけ呼ばなければいけない関数です。</p>

<pre><code class="language-prerender">// キャンバスの大きさを300×200に設定します。
size(300, 200, &#34;2D&#34;);
// キャンバスをピンクで塗りつぶします。
background(250, 200, 200);
</code></pre>

</div><div id="ref-background" class="section"><h1>background</h1>

<p>キャンバスを一つの色で塗りつぶします。色を指定する方法は2つあります。 1個の数値を指定した場合は、グレースケールで明るさを指定します。 0は黒、255は白、その中間は数値に応じた灰色を意味します。例えば</p>

<pre><code class="language-prerender">// BackgroundExample
// キャンバスを灰色に塗ります。
background(150);
</code></pre>

<p>3個の数値を指定した場合は、RGBモデルで任意の色を指定できます。 R (赤)・G (緑)・B (青)それぞれを0から255までの数値で指定します。</p>

<pre><code class="language-prerender">// BackgroundExample
// キャンバスを赤で塗ります。
background(255, 0, 0);
</code></pre>

</div><div id="ref-loop" class="section"><h1>loop</h1>

<p>スケッチの実行ループが止まっているときに<code>loop()</code>を呼ぶと、実行ループを再開します。</p>

<pre><code class="language-prerender">// NoLoopExample
fill(0); textSize(20);

function draw() {
  background(220);
  text(frameCount, 5, 25);
}

function mousePressed() {
  noLoop();
}

function mouseReleased() {
  loop();
}
</code></pre>

<p>関連項目: <a href="#ref-draw">draw()</a>, <a href="#ref-noLoop">noLoop()</a></p>

</div><div id="ref-noLoop" class="section"><h1>noLoop</h1>

<p>スケッチの実行ループを停止します。 なお、マウスなどのイベントが発生したときは対応する関数が呼ばれるので、 スケッチの実行が完全に停止するわけではありません。</p>

<pre><code class="language-prerender">// NoLoopExample
fill(0); textSize(20);

function draw() {
  background(220);
  text(frameCount, 5, 25);
}

function mousePressed() {
  noLoop();
}

function mouseReleased() {
  loop();
}
</code></pre>

<p>関連項目: <a href="#ref-draw">draw()</a>, <a href="#ref-loop">loop()</a>.</p>

</div><div id="ref-Demos" class="section"><h1>Demos</h1>

<ul>
<li>簡単なデモ

<ul>
<li><a href="#ref-ImageSave">ImageSave</a></li>
<li><a href="#ref-ImageRotate">ImageRotate</a></li>
</ul></li>
<li><a href="#ref-Drawing">Drawing</a></li>
<li><a href="#ref-ChaseTheCircle">ChaseTheCircle</a></li>
<li><a href="#ref-DrawFace">DrawFace</a></li>
</ul>

</div><div id="ref-ImageRotate" class="section"><h1>ImageRotate</h1>

<p>このプログラムは、画像を回しています。</p>

<pre><code class="language-prerender">// ImageRotateExample
var img = getImage(&#34;cc0/cat2-185x200.png&#34;);
imageMode(CENTER);

function draw() {
  var angle = (mouseX+mouseY)/45*PI;
  var x = 50, y = 50;
  background(220);
  translate(x, y);
  rotate(frameCount/180*PI);
  image(img, 0, 0, 92, 100);
  rotate(-angle);
  translate(-x, -y);
}
</code></pre>

</div><div id="ref-ImageSave" class="section"><h1>ImageSave</h1>

<p>このプログラムでは、キャンバスを消すことなく、一部だけを保存して、後もとに戻すことで 綺麗なアニメーションが成り立っています。</p>

<pre><code class="language-prerender">// ImageSaveExample
var img = getImage(&#34;cc0/cat2-185x200.png&#34;);
imageMode(CENTER);

var imgSave = null;

function draw() {
  if (imgSave != null) {
    image(imgSave, pmouseX, pmouseY, 100, 100);
  }
  imgSave = get(mouseX-50, mouseY-50, 100, 100);
  image(img, mouseX, mouseY, 92, 100);
}
</code></pre>

</div><div id="ref-Drawing" class="section"><h1>Drawing</h1>

<p>このスケッチでマウスで描くことができます。</p>

<pre><code class="language-example">// Drawing
size(300, 300, &#34;2D&#34;);
stroke(200, 0, 0);
strokeCap(ROUND);
strokeWeight(10);

var penDown = false;

function mousePressed() {
  if (mouseButton === RIGHT) {
    background(200);
    return;
  }
  penDown = true;
}

function mouseReleased() {
  penDown = false;
}

var prevX = 0;
var prevY = 0;

function draw() {
  if (penDown) {
    if (prevX != 0) {
      line(prevX, prevY, mouseX, mouseY);
    }
  }
  prevX = mouseX;
  prevY = mouseY;
}
</code></pre>

</div><div id="ref-ChaseTheCircle" class="section"><h1>ChaseTheCircle</h1>

<pre><code class="language-example">// ChaseTheCircle

// Coordinates of the first circle.
var x1 = 250;
var y1 = 250;
// Coordinates of the second circle.
var x2 = 250;
var y2 = 250;
// Larger -&gt; faster.
var easing = 0.1;

frameRate(60);
stroke(0);

function draw() {
  // Paint the background.
  background(40, 40, 100);

  // The first circle chases the mouse cursor.
  var dx1 = mouseX - x1;
  x1 += dx1 * easing;
  var dy1 = mouseY - y1;
  y1 += dy1 * easing;

  // Draw the first circle.
  fill(0, 220, 0);
  ellipse(x1, y1, 66, 66);

  // The second circle chases the first circle.
  var dx2 = x1 - x2;
  x2 += dx2 * easing;
  var dy2 = y1 - y2;
  y2 += dy2 * easing;

  // Draw the second circle.
  fill(255, 40, 40);
  ellipse(x2, y2, 66, 66);
}
</code></pre>

</div><div id="ref-Games" class="section"><h1>ゲーム</h1>

<ul>
<li><a href="#ref-JumpingBall">JumpingBall</a>

<ul>
<li><a href="#ref-JumpingBall2">JumpingBall2</a></li>
</ul></li>
<li><a href="#ref-TouchTheNumber">TouchTheNumber</a></li>
<li><a href="#ref-IslandHopper">IslandHopper</a></li>
<li><a href="#ref-PingPong">PingPong</a></li>
<li><a href="#ref-RocketLanding">RocketLanding</a></li>
</ul>

</div><div id="ref-RocketLanding" class="section"><h1>RocketLanding</h1>

<pre><code class="language-example">// RocketLanding
var fire = getImage(&#34;cc0/fire2-134x200.png&#34;);
var rocket = getImage(&#34;cc0/rocket-168x300.png&#34;);
var rocket_fire = getImage(&#34;cc0/rocket1-168x300.png&#34;);
var explosion = getSound(&#34;cc0/explosion.ogg&#34;);
var roar = getSound(&#34;cc0/roar.ogg&#34;);
var win = getSound(&#34;cc0/win.ogg&#34;);

var x;
var y;
var vy;

var burning = false;
var gameOver = false;

function initVars() {
  x = 100;
  y = 10;
  vy = 0;
  gameOver = false;
  burning = false;
}

size(200, 200, &#34;2D&#34;);
frameRate(20);
imageMode(CENTER);
initVars();

function draw() {
  y = y + vy;
  vy = vy + 0.2;

  if (y &gt; height - 30) {
    if (abs(vy) &gt; 3) {
      background(200);
      image(fire, x, y-25, 65, 100);
      explosion.play();
    } else {
      win.play();
    }
    noLoop();
    gameOver = true;
    return;
  }

  background(100);
  if (burning) {
    image(rocket_fire, x, y, 34, 60);
    burning = false;
  } else {
    image(rocket, x, y, 34, 60);
  }
}

function burn() {
  burning = true;
  vy -= 2;
  roar.play();
}

function keyPressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}

function mousePressed() {
  if (gameOver) {
    initVars();
    loop();
    return;
  }
  burn();
}
</code></pre>

</div><div id="ref-PingPong" class="section"><h1>PingPong</h1>

<pre><code class="language-example">// PingPong
size(360, 360, &#34;2D&#34;);
background(250);
frameRate(30);

var ballDiameter = 30;
var paddleWidth = 10;
var paddleHeight = 90;

var sleepUntil = 0;

function drawBall(x, y) {
  fill(200);
  stroke(0);
  var deform = 0;
  if (x &lt;= paddleWidth*2 + ballDiameter/2 &amp;&amp;
      y1 - paddleHeight/2 - ballDiameter/2 &lt; y &amp;&amp;
      y &lt; y1 + paddleHeight/2 + ballDiameter/2) {
    deform = (paddleWidth*2 + ballDiameter/2 - x);
  } else if (x &gt;= 360-paddleWidth*2 - ballDiameter/2 &amp;&amp;
             y2 - paddleHeight/2 -ballDiameter/2&lt; y &amp;&amp;
             y &lt; y2 + paddleHeight/2 + ballDiameter/2) {
    deform = (paddleWidth*2 + ballDiameter/2 - (360-x));
  }
  ellipse(x, y, ballDiameter-deform, ballDiameter+deform);
}

function drawPaddle(x, y) {
  fill(100);
  stroke(0);
  rect(x - paddleWidth/2, y - paddleHeight/2, paddleWidth, paddleHeight);
}

// Ball coordinates.
var x = 180, y = 180;
// Ball velocity.
var vx = 5, vy = 5;
var lastPlayer1inputMs = 0;
var lastPlayer2inputMs = 0;

var updateBall() {
  if (y &lt; 10 &amp;&amp; vy &lt; 0) {
    vy = -vy - 1 + random(2);
  }
  if (y &gt; 350 &amp;&amp; vy &gt; 0) {
    vy = -vy - 1 + random(2);
  }
  if (x &lt;= paddleWidth + ballDiameter/2 &amp;&amp;
      y1 - paddleHeight/2 - ballDiameter/2 &lt; y &amp;&amp;
      y &lt; y1 + paddleHeight/2 + ballDiameter/2) {
    vx = 5 + random(2);
  }
  if (x &gt;= 360-paddleWidth - ballDiameter/2 &amp;&amp;
      y2 - paddleHeight/2 -ballDiameter/2&lt; y &amp;&amp;
      y &lt; y2 + paddleHeight/2 + ballDiameter/2) {
    vx = -7 + random(2);
  }
  x += vx;
  y += vy;
  if (x &lt; 10 || x &gt; 350) {
    sleepUntil = millis() + 2000;
    background(250);
    textSize(30);
    fill(0);
    if (x &lt; 10) {
      text(&#34;Player B won!&#34;, 100, 180);
    } else {
      text(&#34;Player A won!&#34;, 100, 180);
    }
    x = 180;
    y = 0;
    vx = -5;
    return false;
  }
  return true;
}

function draw() {
  if (millis() &lt; sleepUntil) {
    return;
  }
  if (!updateBall()) {
    return;
  }
  background(255);
  drawPaddle(10, y1);
  drawPaddle(345, y2);
  drawBall(x, y);
  textSize(10);
  text(str(x) + &#34;,&#34; + str(y)+&#34;  &#34;+y1+&#34; &#34; + y2, 10, 10);
  if (random(70) &lt; 10 &amp;&amp; millis() - lastPlayer1inputMs &gt; 5000) {
    y1 = y;
  } else if (random(90) &lt; 10 &amp;&amp; millis() - lastPlayer2inputMs &gt; 5000) {
    y2 = y;
  }
}

var y1 = 180;
var y2 = 180;

function mouseMoved() {
  y1 = mouseY;
  lastPlayer1inputMs = millis();
}

function keyPressed() {
  var ms = millis() - lastPlayer2inputMs;
  if (keyCode == UP) {
    if (ms &lt; 100) {
      y2 -= 100;
    } else if (ms &lt; 200) {
      y2 -= 50;
    } else {
      y2 -= 10;
    }
  } else if (keyCode = DOWN) {
    if (ms &lt; 100) {
      y2 += 100;
    } else if (ms &lt; 200) {
      y2 += 50;
    } else {
      y2 += 10;
    }
  }
  lastPlayer2inputMs = millis();
}
</code></pre>

</div><div id="ref-IslandHopper" class="section"><h1>IslandHopper</h1>

<pre><code class="language-example">// IslandHopper
var location = 0;
var sizes = [30, 30, 20, 30, 20, 10, 30];
var N = sizes.length;

frameRate(10);
stroke(0);
fill(255);

var margin = 30;
var islandR = 30;
var islandAspect = 4;
var islandH = height-20;
var step = (width - 2*margin) / (N-1);

var negSizeThreshold = -3;

var humanHeight = 50;
var humanWidth = 20;
var humanHeadR = 10;
var humanY = islandH;

var gameOver = false;
var message = &#34;GAME OVER&#34;;

function initialize() {
  location = 0;
  gameOver = false;
  humanY = islandH;
  message = &#34;GAME OVER&#34;;
}


function drawHuman(x, y) {
  line(x, y-humanHeight/3, x, y-humanHeight);
  line(x-humanWidth/2, y, x, y-humanHeight/3);
  line(x+humanWidth/2, y, x, y-humanHeight/3);
  line(x-humanWidth/2, y-humanHeight*4/5, x+humanWidth/2, y-humanHeight*4/5);
  ellipse(x, y-humanHeight-humanHeadR, humanHeadR*2, humanHeadR*2);
}

function drawIsland(x, s) {
  ellipse(x, islandH, s, islandW);
}

function redraw() {
  background(200);
  drawHuman(margin + location*step, humanY);
  for (var i = 0; i &lt; N; i++) {
    var s = sizes[i];
    if (s &gt; 0) {
      if (s &gt; islandR) s = islandR;
      ellipse(margin + i*step, islandH, s, s/islandAspect);
    }
  }
  drawHuman(margin + location*step, humanY);
  if (gameOver) {
    textSize(40);
    fill(0);
    text(message, 30, height/2+10);
    fill(255);
  }
}

function shrinkIslands() {
  for (var i = 1; i &lt; N-1; i++) {
    if (sizes[i] &gt; -random(negSizeThreshold)) {
      sizes[i] -= 1;
    } else {
      sizes[i] = random(islandR) + islandR;
    }
  }
}

function pullHuman() {
  if (humanY &lt; islandH) {
    humanY += humanHeight/10;
  }
  if (humanY &gt; islandH) {
    humanY = islandH;
  }
}

function advanceTime() {
  shrinkIslands();
  pullHuman();
}

function checkGround() {
  var s = sizes[location];
  if (humanY == islandH &amp;&amp; s &lt; humanWidth-2) {
    humanY = height;
    gameOver = true;
    redraw();
    noLoop();
    return;
  }
  if (location == sizes.length-1 &amp;&amp; humanY == islandH) {
    message = &#34;YOU WON&#34;;
    gameOver = true;
  }
}

function draw() {
  if (gameOver) return;
  advanceTime();
  checkGround();
  redraw();
}

function keyPressed() {
  if (gameOver) {
    if (keyCode == &#39; &#39;) {
      initialize();
      loop();
    }
    return;
  }
  switch (keyCode) {
    case LEFT: if (location &gt; 0) location--; break;
    case RIGHT: if (location &lt; sizes.length-1) location++; break;
    case 32:
      if (humanY == islandH) {
        humanY -= humanHeight;
      }
      break;
  }
  checkGround();
  redraw();
}

function mouseClicked() {
  if (gameOver) {
    initialize();
    loop();
  }
}
</code></pre>

</div><div id="ref-JumpingBall" class="section"><h1>JumpingBall</h1>

<pre><code class="language-example">// JumpingBall

var groundHeight = 10;
var skyHeight = height - groundHeight - 10;

var walls = [];
var ball;

var Wall = function(init_x, init_y) {
  this.x = init_x;
  this.y = init_y;
};

function drawGround() {
  for (var start = -(4 * frameCount % 11); start &lt; width; start += 11) {
    fill(100, 100, 100);
    rect(start, skyHeight, 11, groundHeight);
  }
}

function draw() {
  background(255, 255, 255);
  if (frameCount % 50 === 0) {
    walls.push(new Wall(width, random(skyHeight / 2)));
  }

  for (var i = 0; i &lt; walls.length; ++i) {
   walls[i].update();
    if (ball.hit(walls[i])) {
      noLoop();
    }
    if (walls[i].x &lt; 0) {
      walls.shift();
      i--;
      continue;
    }
    walls[i].draw();
  }

  drawGround();
  ball.update();
  ball.draw();
}

function mouseClicked() {
  if (ball.y &lt;= ball.r) {
   ball.v = 20;
  }
}


var Ball = function(init_x, init_y, init_r) {
  this.x = init_x;
  this.y = init_y;
  this.r = init_r;
  this.v = 0;
};

Ball.prototype.update = function() {
  if (this.v &lt; 0 &amp;&amp; this.y - this.r &lt;= 0) {
    this.v = 0;
    this.y = this.r;
  } else {
    this.y += this.v;
    this.v--;
  }
};

Ball.prototype.hit = function(w) {
  if (w.x &gt; this.x + this.r || w.x &lt; this.x - this.r) {
      return false;
  }
  return this.y - this.r &lt; w.y;
};

Ball.prototype.draw = function() {
  fill(0, 0, 0);
  ellipse(this.x, skyHeight - 1 - this.y, this.r*2, this.r*2);
};


Wall.prototype.update = function() {
  this.x -= 4;
};

Wall.prototype.draw = function() {
  fill(0, 255, 0);
  rect(this.x, skyHeight - 1 - this.y, 5, this.y);
};


var ball = new Ball(40, 20, 20);
var walls = [];

</code></pre>

</div><div id="ref-JumpingBall2" class="section"><h1>JumpingBall2</h1>

<pre><code class="language-example">// JumpingBall2
var img = getImage(&#34;cc0/football1-200x200.png&#34;);
var fire = getImage(&#34;cc0/fire1-200x123.png&#34;);
imageMode(CENTER);

// 座標
var x = 100;
var y = 100;
// 速度
var vx = 0;
var vy = 0;
// 加速度
var ax = 0.99;
var ay = 0.1;

var fireX = 200;
var fireY = 300;
var fireV = 1;
var fireVX = 0.5;
var fireVY = -0.1;
var fireAngle = 0;

var goalX = 450;
var goalY = 465;

var gameOver = false;
String gameMessage = &#34;&#34;;

function initializeVars() {
  x = 100;
  y = 100;
  vx = 0;
  vy = 0;
}

initializeVars();

function draw() {
  updatePosition();
  drawFrame();
}


function updatePosition() {
  // 座標や速度の計算。
  x = x + vx;
  y = y + vy;
  if (vx != 0) {
    vx = vx*abs(vx*ax)/abs(vx);
  }
  vy = vy + ay;
  /*
  if (y &gt; height-5) {
    gameOver = true;
    gameMessage = &#34;GAME OVER&#34;;
    return;
  }
  */
  // バウンス
  if (x &lt; 5) {
    x = 5;
    vx = abs(vx);
  }
  if (x &gt; width-5) {
    x = width - 5;
    vx = -abs(vx);
  }
  if (y &lt; 5) {
    y = 5;
    vy = abs(vy);
  }
  if (y &gt; height-5) {
    y = height-5;
    vy = -abs(vy);
  }
  fireX += fireVX;
  fireY += fireVY;
  fireAngle += 0.02;
  fireVX = fireV*cos(fireAngle) + fireV*sin(fireAngle);
  fireVY = fireV*sin(fireAngle) - fireV*cos(fireAngle);

  if (dist(x, y, fireX, fireY) &lt; 100 &amp;&amp; abs(y - fireY) &lt; 60) {
    gameOver = true;
    gameMessage = &#34;GAME OVER&#34;;
  }
  if (dist(x, y, goalX, goalY) &lt; 25 &amp;&amp; y &lt;= goalY) {
    gameOver = true;
    gameMessage = &#34;YOU WON&#34;;
  }
}


function drawFrame() {
  if (gameOver) {
    background(220);
    fill(0);
    textSize(20);
    text(gameMessage, 30, 100);
    noLoop();
    return;
  }
  background(220);
  strokeWeight(3);
  fill(255);
  ellipse(goalX, goalY, 45, 25);
  fill(255);
  //ellipse(x, y, 10, 10);
  image(img, x, y,  40, 40);
  translate(fireX, fireY);
  image(fire, 0, 0, 200, 130);
  translate(-fireX, -fireY);
}

function keyPressed() {
  if (gameOver) {
    gameOver = false;
    initializeVars();
    loop();
    return;
  }
  switch (key) {
    case &#39; &#39;:
      break;
    case &#39;\n&#39;:
      break;
    case &#39;q&#39;:
      gameOver = true;
      gameMessage = &#34;STOP&#34;;
      break;
  }
  switch (keyCode) {
    case UP:
      vy -= 5;
      break;
    case DOWN:
      vy += 5;
      break;
    case LEFT:
      vx = -2;
      break;
    case RIGHT:
      vx = 2;
      break;
  }
}

</code></pre>

</div><div id="ref-TouchTheNumber" class="section"><h1>TouchTheNumber</h1>

<pre><code class="language-example">// TouchTheNumber

var N = 3;
var numbers[][];

// Draw the rectangles.
function rectangles() {
  fill(200);
  for (var i = 0; i &lt; N; i++) {
    for (var j = 0; j &lt; N; j++) {
      rect(50+120*i, 50+120*j, 100, 100);
    }
  }
}

function printNumbers() {
  fill(0);
  textSize(50);
  for (var i = 0; i &lt; N; i++) {
    for (var j = 0; j &lt; N; j++) {
      text(str(numbers[i][j]), 85+120*i, 118+120*j);
    }
  }
}

function shuffle() {
  for (var i = 0; i &lt; N; i++) {
    for (var j = 0; j &lt; N; j++) {
      var x = int(random(N));
      var y = int(random(N));
      if (x != i || y != j) {
        var tmp = numbers[i][j];
        numbers[i][j] = numbers[x][y];
        numbers[x][y] = tmp;
      }
    }
  }
}

background(240);
textSize(50);
numbers = new int[N][];
for (var i = 0; i &lt; N; i++) {
  numbers[i] = new int[N];
  for (var j = 0; j &lt; N; j++) {
    numbers[i][j] = i*3 + j + 1;
  }
}
shuffle();
rectangles();
printNumbers();

var current = 1;
var started = false;
var started_ms = 0;

function draw() {
  noLoop();
}

function mouseOver() {
  if (!started) {
    started = true;
    background(240);
    rectangles();
    started_ms = millis();
  }
}

var lastClickMs;

function mouseClicked() {
  // Ignore click repeats (touch screen generates too many click events).
  if (millis() - lastClickMs &lt; 50) return;
  lastClickMs = millis();
  if (!started) {
    started = true;
    background(240);
    rectangles();
    started_ms = millis();
  }
  if (current == 10) {
    background(240);
    rectangles();
    shuffle();
    printNumbers();
    current = 1;
    started = false;
    return;
  }
  var x = int((mouseX-60)/120);
  var y = int((mouseY-60)/120);
  if (x &lt; 0) x = 0;
  if (x &gt;= N) x = N-1;
  if (y &lt; 0) y = 0;
  if (y &gt;= N) y = N-1;
  //fill(240); stroke(240);
  //rect(20, 20, 50, 20);
  //textSize(20); fill(0); stroke(0);
  //text(str(mouseX) + &#34; &#34; + str(mouseY)+&#34; : &#34; + str(x) + &#34; &#34; + str(y), 20, 20);
  if (numbers[x][y] == current) {
    textSize(50);
    fill(0);
    text(str(numbers[x][y]), 85+120*x, 118+120*y);
    current++;
    if (current == 10) {
      background(240);
      var t = millis() - started_ms;
      fill(0); textSize(50);
      text(str(int(t/1000)) + &#34;.&#34; + str((int(t/100))%10) + str((int(t/10))%10) + &#34;s&#34;, 100, 100);
    }
  }
}
</code></pre>

</div><div id="ref-ellipse" class="section"><h1>ellipse</h1>

<p>円または楕円を描きます。</p>

<pre><code class="language-prerender">// EllipseExample
ellipse(50, 25, 90, 20);
</code></pre>

<pre><code class="language-prerender">// EllipsesExample
fill(255, 0, 0); // 赤
// 横に細長い赤い楕円を描きます。
ellipse(50, 10, 100, 20);
fill(0, 0, 255); // 青
// 縦の細長い楕円を描きます。
ellipse(10, 50, 20, 100);
fill(255);  // 白
ellipse(50, 50, 40, 40);
</code></pre>

<p>呼び方: <code>ellipse(x, y, width, height)</code></p>

<ul>
<li><code>x</code> — 中心のX座標</li>
<li><code>y</code> — 中心のY座標</li>
<li><code>width</code> — 楕円の幅</li>
<li><code>height</code> — 楕円の高さ</li>
</ul>

<p><code>weight</code>と<code>height</code>を等しくすれば円を描くことができます。</p>

<p>関連項目: <a href="#ref-arc">arc()</a>, <a href="#ref-triangle">triangle()</a>, <a href="#ref-rect">rect()</a>, <a href="#ref-ellipse">ellipse()</a></p>

</div><div id="ref-Ball" class="section"><h1>Ball</h1>

<p>Ball: 玉。ボール。</p>

</div><div id="ref-Wall" class="section"><h1>Wall</h1>

<p>Wall: 壁</p>

</div><div id="ref-add" class="section"><h1>add</h1>

<p>足す。付き加える。</p>

</div><div id="ref-alert" class="section"><h1>alert</h1>

<p>警報。アラート。<code>alert(text)</code>はブラウザに<code>text</code>のテキストを警報します。</p>

</div><div id="ref-drawGround" class="section"><h1>drawGround</h1>

<p>地面を描く。</p>

</div><div id="ref-fill" class="section"><h1>fill</h1>

<p><code>fill()</code>は図形の中を塗りつぶす色を設定します。<code>fill()</code> を呼んだ後に <code>ellipse()</code> や <code>rect()</code> などで楕円や四角形を描くと、その中が<code>fill()</code>で指定した色で塗りつぶされます。</p>

<pre><code class="language-prerender">// FillExample
fill(0, 255, 0);  // 緑
ellipse(50, 50, 50, 25);
</code></pre>

<p>色の指定の仕方については color() の説明を見てください。</p>

<p>塗りつぶす色ではなく図形の外側の線の色を指定するには、stroke() の説明を見てください。</p>

<p>関連項目: <a href="#ref-noFill">noFill()</a>, <a href="#ref-stroke">stroke()</a>, <a href="#ref-noStroke">noStroke()</a></p>

</div><div id="ref-hit" class="section"><h1>hit</h1>

<p>当たる、打つかる。</p>

</div><div id="ref-false" class="section"><h1>false</h1>

<p>真理値の一つ。「偽」という意味。<a href="#ref-boolean">boolean</a>を見てください。</p>

</div><div id="ref-true" class="section"><h1>true</h1>

<p>真理値の一つ。「真」という意味。<a href="#ref-boolean">boolean</a>を見てください。</p>

</div><div id="ref-boolean" class="section"><h1>boolean</h1>

<p><code>boolean</code>は真理値の型です。真理値には2つの値があります。</p>

<ul>
<li><code>true</code> 「真」</li>
<li><code>false</code> 「偽」</li>
</ul>

<p><a href="#ref-if">if()</a>と<a href="#ref-while">while()</a>のカッコの中の値は真理値でなければなりません。</p>

</div><div id="ref-void" class="section"><h1>void</h1>

<p><code>void</code>は何も返さない関数の型です。関数が値を返す必要がないときに使います。</p>

</div><div id="ref-char" class="section"><h1>char</h1>

<p><code>char</code>は一つの文字のコードポイント(符号点)を保存する整数の型です。</p>

<pre><code>char c = &#39;d&#39;; // 100.
</code></pre>

</div><div id="ref-int" class="section"><h1>int</h1>

<p>整数の型です。整数は…, -3, -2, -1, 0, 1, 2, 3, 4, …などの数です。</p>

</div><div id="ref-float" class="section"><h1>float</h1>

<p>単精度浮動小数点数の型です。</p>

<p><strong>注意:</strong> Processing.jsでは、変数に付く型が倍精度(double)である。</p>

</div><div id="ref-double" class="section"><h1>double</h1>

<p>倍精度浮動小数点数変の型です。</p>

</div><div id="ref-byte" class="section"><h1>byte</h1>

<p>-128以上127以下の整数の型です。</p>

<p><strong>注意:</strong> Processing.jsでは変数につけている型は倍精度(double)であるため、使う時点で<code>byte()</code>で変換が必要である。</p>

<pre><code class="language-prerender">fill(0); textSize(20);
byte x = byte(257);
text(str(x), 10, 30);
</code></pre>

</div><div id="ref-short" class="section"><h1>short</h1>

<p>-32768以上32767以下の整数の型です。</p>

<p><strong>注意:</strong> Processing.jsでは変数につけている型は倍精度(double)であるため、使う時点で<code>short()</code>で変換が必要である。</p>

</div><div id="ref-line" class="section"><h1>line</h1>

<p><code>line()</code>はキャンバスに直線を描きます。</p>

<pre><code class="language-prerender">// LineExample
var x1 = 10, y1 = 10, y2 = 100, x2 = 50;
// (x1, y1)から(x2, y2)までの直線を描きます。
line(x1, y1, x2, y2);
</code></pre>

<p>関連項目: <a href="#ref-triangle">triangle()</a>, <a href="#ref-rect">rect()</a>, <a href="#ref-ellipse">ellipse()</a>, <a href="#ref-arc">arc()</a>.</p>

</div><div id="ref-millis" class="section"><h1>millis</h1>

<p>プログラム開始から現在までの経過時間をミリ秒単位で返します。
注意：プログラムの編集のときは、プログラムをそのまま実行し続ける場合がありますので、
<code>millis()</code>は0にならないで、そのまま増え続きます。</p>

<p>例えば、このプログラムは実行を始めてから2秒後に赤い円を描きます。</p>

<pre><code class="language-prerender">// MillisExample
size(150, 100, &#34;2D&#34;);
background(255);  // キャンバスを白で塗ります
fill(0);
textSize(20);
text(&#34;2秒待って&#34;, 10, 50);
var start = millis();

function draw() {
  if (millis() - start &gt; 2000) {  // 2000ミリ秒=2秒
    background(255);
    fill(255, 0, 0); // 赤
    ellipse(75, 50, 55, 55);
    noLoop(); // アニメーションを止めます。
  }
}
</code></pre>

</div><div id="ref-mouseClicked" class="section"><h1>mouseClicked</h1>

<p><code>mouseClicked()</code> を定義すると、ユーザがマウスをクリックしたときに呼ばれます。 マウスのクリックに反応するプログラムを作るにはこの関数を定義しなければなりません。カーソルの位置は<code>mouseX</code>と<code>mouseY</code>変数を使って調べることができます。 クリックされたボタンは<code>mouseButton</code>変数を使って調べることができます。クリックされたボタンによって<code>mouseButton</code>の値は<code>LEFT</code>か<code>RIGHT</code>かになります。</p>

<p>右側のキャンバスにマウスクリックしてください。</p>

<pre><code class="language-prerender">// MouseClickedExample
background(255);

function mouseClicked() {
  fill(0);
  ellipse(mouseX, mouseY, 20, 20);
}
</code></pre>

<p>関連項目: <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>, <a href="#ref-mouseX">mouseX</a>, <a href="#ref-mouseY">mouseY</a>.</p>

</div><div id="ref-mouseMoved" class="section"><h1>mouseMoved</h1>

<p><a href="#ref-Mouse">マウスイベント</a>: <code>mouseMoved()</code>を定義すると、マウスカーソルを動かしたときに呼ばれます。</p>

<p>右側のキャンバスにマウスを動かしてみてください。</p>

<pre><code class="language-prerender">// MouseMovedExample

function mouseMoved() {
  line(pmouseX, pmouseY, mouseX, mouseY);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseClicked">mouseClicked()</a>, <a href="#ref-mouseDragged">mouseDragged()</a>, <a href="#ref-mouseOver">mouseOver()</a>, <a href="#ref-mouseOut">mouseOut()</a>.</p>

</div><div id="ref-mouseDragged" class="section"><h1>mouseDragged</h1>

<p><a href="#ref-Mouse">マウスイベント</a>: mouseDragged()を定義すると、マウスを押したまま動かしたときに呼ばれます。</p>

<p>右側のキャンバスにマウスをクリックして、押したまま動かしてみてください。</p>

<pre><code class="language-prerender">// MouseDraggedExample

function mouseDragged() {
  line(pmouseX, pmouseY, mouseX, mouseY);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseClicked">mouseClicked()</a>, <a href="#ref-mouseMoved">mouseMoved()</a>, <a href="#ref-mouseOver">mouseOver()</a>, <a href="#ref-mouseOut">mouseOut()</a>.</p>

</div><div id="ref-mouseOver" class="section"><h1>mouseOver</h1>

<p><code>mouseOver()</code> を定義すると、ユーザがマウスをキャンバスの外から中に動かしたときに呼ばれます。</p>

<pre><code class="language-prerender">// MouseOverExample
background(220);
fill(0); textSize(15);
text(&#34;待っています&#34;, 5, 20);

function mouseOver() {
  background(80); fill(255);
  text(&#34;スタート&#34;, 20, 20);
}

function mouseOut() {
  background(0); fill(255);
  text(&#34;終わり&#34;, 20, 20);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseOut">mouseOut()</a>, <a href="#ref-mouseMoved">mouseMoved()</a>.</p>

</div><div id="ref-mouseOut" class="section"><h1>mouseOut</h1>

<p><code>mouseOut()</code> を定義すると、ユーザがマウスをキャンバスの中から外に動かした時に呼ばれます。</p>

<pre><code class="language-prerender">// MouseOutExample
background(220);
fill(0); textSize(15);
text(&#34;待っています&#34;, 5, 20);

function mouseOver() {
  background(80); fill(255);
  text(&#34;スタート&#34;, 20, 20);
}

function mouseOut() {
  background(0); fill(255);
  text(&#34;終わり&#34;, 20, 20);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseOver">mouseOver()</a>, <a href="#ref-mouseMoved">mouseMoved()</a>.</p>

</div><div id="ref-mousePressed" class="section"><h1>mousePressed</h1>

<p><code>mousePressed()</code> を定義すると、ユーザがマウスのボタンを押したときに呼ばれます。この関数を定義すると、「マウスで絵を描く」のような操作が実装できます。</p>

<pre><code class="language-prerender">// MousePressedExample
background(128);
fill(240);

var pressed = false;

// キャンバスの中でマウスの左ボタンか右ボタンが押されたら、
// それに対応して塗りつぶしとペンの色を設定する。
function mousePressed() {
  pressed = true;
  if (mouseButton === LEFT) {
    fill(0); stroke(0);
  } else if (mouseButton === RIGHT) {
    fill(255); stroke(255);
  }
}

function mouseReleased() {
  pressed = false;
}

function draw() {
  if (pressed) {
    ellipse(mouseX, mouseY, 5, 5);
  }
}
</code></pre>

<p>関連項目: <a href="#ref-mouseReleased">mouseReleased()</a>, <a href="#ref-mouseMoved">mouseMoved()</a>.</p>

</div><div id="ref-mouseReleased" class="section"><h1>mouseReleased</h1>

<p><code>mouseReleased()</code> を定義すると、ユーザがマウスのボタンを離したときに呼ばれます。この関数を定義すれば、「マウスで絵を描く」のような操作が実装できます。</p>

<pre><code class="language-prerender">// MouseReleasedExample
background(128);
fill(240); noStroke();

var pressed = false;

function mousePressed() {
  pressed = true;
}

function mouseReleased() {
  pressed = false;
}

function draw() {
  if (pressed) {
    ellipse(mouseX, mouseY, 10, 10);
  }
}
</code></pre>

<p>関連項目: <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseMoved">mouseMoved()</a>.</p>

</div><div id="ref-mouseButton" class="section"><h1>mouseButton</h1>

<p><a href="#ref-Mouse">マウスイベント</a>の中で使い、押されたボタンを表します。 押されたボタンが左ボタンのときは<code>LEFT</code>に、右ボタンがときは<code>RIGHT</code>になります。</p>

<pre><code class="language-prerender">// MouseButtonExample
// キャンバスの中でマウスボタンが押してみましょう。
background(220);
function mousePressed() {
  if (mouseButton === LEFT) {
    fill(0);
    rect(5,5,40,90);
  } else if (mouseButton === RIGHT) {
    fill(0);
    rect(55,5,40,90);
  } else {
    fill(0);
    rect(45,5,10,90);
  }
}

function mouseReleased() {
  background(200);
}
</code></pre>

</div><div id="ref-mouseX" class="section"><h1>mouseX</h1>

<p>マウスのX座標。<a href="#ref-draw">draw()</a>からも<a href="#ref-Mouse">マウスイベント</a>からも参照できます。</p>

<pre><code class="language-prerender">// MouseExample
function draw() {
  ellipse(mouseX, mouseY, 5, 5);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseY">mouseY</a>, <a href="#ref-pmouseX">pmouseX</a>, <a href="#ref-pmouseY">pmouseY</a>, <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>,
<a href="#ref-mouseClicked">mouseClicked()</a>.</p>

</div><div id="ref-pmouseX" class="section"><h1>pmouseX</h1>

<p>前のフレームでの<a href="#ref-mouseX">mouseX</a>の値です。</p>

<pre><code class="language-prerender">// MouseExample
function draw() {
  line(pmouseX, pmouseY, mouseX, mouseY);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseX">mouseX</a>, <a href="#ref-mouseY">mouseY</a>, <a href="#ref-pmouseY">pmouseY</a>.</p>

</div><div id="ref-pmouseY" class="section"><h1>pmouseY</h1>

<p>前のフレームでの<a href="#ref-mouseY">mouseY</a>の値です。</p>

<pre><code class="language-prerender">// MouseExample
function draw() {
  line(pmouseX, pmouseY, mouseX, mouseY);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseX">mouseX</a>, <a href="#ref-mouseY">mouseY</a>, <a href="#ref-pmouseX">pmouseX</a>.</p>

</div><div id="ref-mouseY" class="section"><h1>mouseY</h1>

<p>マウスのY座標。<a href="#ref-draw">draw()</a>からも<a href="#ref-Mouse">マウスイベント</a>からも参照できます。</p>

<pre><code class="language-prerender">// MouseExample
function draw() {
  ellipse(mouseX, mouseY, 5, 5);
}
</code></pre>

<p>関連項目: <a href="#ref-mouseY">mouseY</a>, <a href="#ref-pmouseX">pmouseX</a>, <a href="#ref-pmouseY">pmouseY</a>, <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>,
<a href="#ref-mouseClicked">mouseClicked()</a>.</p>

</div><div id="ref-LEFT" class="section"><h1>LEFT</h1>

<p><strong>マウス</strong>: <code>LEFT</code>は<a href="#ref-mouseButton">mouseButton</a>を参照するときにマウスの左ボタンを表す。</p>

<p>関連項目: <a href="#ref-mouseButton">mouseButton</a>, <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>, <a href="#ref-mouseClicked">mouseClicked()</a>.</p>

<p><strong>キーボード</strong>: 左の矢印キーのコード。一覧は<a href="#ref-keyCodes">keyCodes</a>に参照。 <code>keyCode === LEFT</code>を調べる先に<code>key ==
CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-CENTER" class="section"><h1>CENTER</h1>

<p><strong>マウス</strong>: <code>CENTER</code>は<a href="#ref-mouseButton">mouseButton</a>を参照するときにマウスの真ん中ボタンを表す。</p>

<p>関連項目: <a href="#ref-mouseButton">mouseButton</a>, <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>, <a href="#ref-mouseClicked">mouseClicked()</a>.</p>

</div><div id="ref-RIGHT" class="section"><h1>RIGHT</h1>

<p><strong>マウス</strong>: <code>RIGHT</code>は<a href="#ref-mouseButton">mouseButton</a>を参照するときにマウスの右ボタンを表す。</p>

<p>関連項目: <a href="#ref-mouseButton">mouseButton</a>, <a href="#ref-mousePressed">mousePressed()</a>, <a href="#ref-mouseReleased">mouseReleased()</a>, <a href="#ref-mouseClicked">mouseClicked()</a>.</p>

<p><strong>キーボード</strong>: 右の矢印キーのコード。一覧は<a href="#ref-keyCodes">keyCodes</a>に参照。 <code>keyCode === RIGHT</code>を調べる先に<code>key ==
CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-printNumbers" class="section"><h1>printNumbers</h1>

<p>数値を表示する。</p>

</div><div id="ref-random" class="section"><h1>random</h1>

<p><code>random(min, max)</code> は <code>min</code>, <code>max</code> で与えられた範囲のなかからランダムな値(乱数)を返します。 返された値 <code>r</code> は <code>min &lt;= r &lt; max</code> を満たします。</p>

</div><div id="ref-rect" class="section"><h1>rect</h1>

<p><code>rect()</code>は長方形を描きます。長方形の位置は2つの対角の頂点の座標で指定します。</p>

<pre><code class="language-prerender">// RectExample
fill(100);
rect(20, 30, 60, 40);
</code></pre>

<p>関連項目: <a href="#ref-fill">fill()</a>, <a href="#ref-stroke">stroke()</a>, <a href="#ref-line">line()</a>, <a href="#ref-triangle">triangle()</a>, <a href="#ref-point">point()</a></p>

</div><div id="ref-remove" class="section"><h1>remove</h1>

<p>なくす、処分する。</p>

</div><div id="ref-shuffle" class="section"><h1>shuffle</h1>

<p>順番をみだす、順不同にする。</p>

</div><div id="ref-sqrt" class="section"><h1>sqrt</h1>

<p><code>sqrt()</code>は与えられた数の平方根を計算します。例えば、<code>sqrt(4.0)</code>は2.0を返します。</p>

<pre><code class="language-prerender">// SqrtExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 36;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;sqrt(x) = &#39; + sqrt(x), 10, 60);
</code></pre>

</div><div id="ref-str" class="section"><h1>str</h1>

<p><code>str()</code>は任意の値を文字列(テキスト)に変換します。</p>

</div><div id="ref-stroke" class="section"><h1>stroke</h1>

<p><code>stroke()</code>はペンの色を設定します。以降の線や図形を描く命令に反映されます。</p>

<pre><code class="language-prerender">// StrokeExample
strokeWeight(5);
stroke(255, 180, 0);  // オレンジ
line(20, 20, 80, 20);
stroke(180, 255, 0);  // 黄緑
line(20, 40, 80, 40);
stroke(0, 255, 180);  // 青
line(20, 60, 80, 60);
</code></pre>

<p>関連項目: <a href="#ref-noStroke">noStroke()</a>, <a href="#ref-strokeCap">strokeCap()</a>, <a href="#ref-fill">fill()</a>.</p>

</div><div id="ref-strokeCap" class="section"><h1>strokeCap</h1>

<p><code>strokeCap()</code>はペンの端の形を設定します。次の<a href="#ref-line">line()</a>命令に反映されます。</p>

<pre><code class="language-prerender">size(200, 100, &#34;2D&#34;);
fill(0); textSize(15);
strokeWeight(16);
strokeCap(ROUND);
line(20, 20, 80, 20);
text(&#34;ROUND&#34;, 100, 20);
strokeCap(SQUARE);
line(20, 50, 80, 50);
text(&#34;SQUARE&#34;, 100, 50);
strokeCap(PROJECT);
line(20, 80, 80, 80);
text(&#34;PROJECT&#34;, 100, 80);
</code></pre>

<p>関連項目: <a href="#ref-stroke">stroke</a>, <a href="#ref-fill">fill</a>, <a href="#ref-ROUND">ROUND</a>, <a href="#ref-SQUARE">SQUARE</a>, <a href="#ref-PROJECT">PROJECT</a>.</p>

<p>選択できる形は</p>

<ul>
<li><code>ROUND</code> - 丸い</li>
<li><code>SQUARE</code> - 四角い。線は座標で表している点までぴったり及びます。</li>
<li><code>PROJECT</code> - 四角い。線は座標で表している点から筆の大きさの部分まで出ています。</li>
</ul>

</div><div id="ref-ROUND" class="section"><h1>ROUND</h1>

<p>線を描く筆を丸い形に設定します。 <a href="#ref-strokeCap">strokeCap()</a>を見てください。</p>

<pre><code class="language-prerender">strokeCap(ROUND);
strokeWeight(20);
line(20, 20, 80, 80);
</code></pre>

<p>関連項目: <a href="#ref-strokeCap">strokeCap</a>, <a href="#ref-strokeWeight">strokeWeight</a>, <a href="#ref-stroke">stroke</a>, <a href="#ref-SQUARE">SQUARE</a>, <a href="#ref-PROJECT">PROJECT</a>.</p>

</div><div id="ref-SQUARE" class="section"><h1>SQUARE</h1>

<p>線を描く筆を四角い形に設定します。 <a href="#ref-strokeCap">strokeCap()</a>を見てください。</p>

<pre><code class="language-prerender">strokeCap(SQUARE);
strokeWeight(20);
line(20, 20, 80, 80);
</code></pre>

<p>関連項目: <a href="#ref-strokeCap">strokeCap</a>, <a href="#ref-strokeWeight">strokeWeight</a>, <a href="#ref-stroke">stroke</a>, <a href="#ref-ROUND">ROUND</a>, <a href="#ref-PROJECT">PROJECT</a>.</p>

</div><div id="ref-PROJECT" class="section"><h1>PROJECT</h1>

<p>線を描く筆を四角い形に設定します。<a href="#ref-SQUARE">SQUARE</a>と比べて、筆の大きさは線の先端に出ています。 <a href="#ref-strokeCap">strokeCap()</a>を見てください。</p>

<pre><code class="language-prerender">strokeCap(PROJECT);
strokeWeight(20);
line(20, 20, 80, 80);
</code></pre>

<p>関連項目: <a href="#ref-strokeCap">strokeCap</a>, <a href="#ref-strokeWeight">strokeWeight</a>, <a href="#ref-stroke">stroke</a>, <a href="#ref-ROUND">ROUND</a>, <a href="#ref-SQUARE">SQUARE</a>.</p>

</div><div id="ref-strokeWeight" class="section"><h1>strokeWeight</h1>

<p><code>strokeWeight()</code>はペンの太さを設定します。以降の線や図形を描く命令に反映されます。</p>

<pre><code class="language-prerender">// StrokeWeightExample
size(200, 100, &#34;2D&#34;);
strokeWeight(5); fill(0); textSize(15);
line(15, 20, 65, 20);
text(&#34;strokeWeight(5)&#34;, 80, 20);
strokeWeight(10);
line(15, 40, 65, 40);
text(&#34;strokeWeight(10)&#34;, 80, 40);
strokeWeight(20);
line(15, 70, 65, 70);
text(&#34;strokeWeight(20)&#34;, 80, 70);
</code></pre>

<p>関連項目: <a href="#ref-stroke">stroke()</a>, <a href="#ref-strokeWeight">strokeWeight()</a>, <a href="#ref-SQUARE">SQUARE</a>.</p>

</div><div id="ref-noFill" class="section"><h1>noFill</h1>

<p><code>noFill()</code>は図形の内蔵を塗りつぶさないように設定します。</p>

<pre><code class="language-prerender">// NoFillExample
noFill(); stroke(150);
rect(20, 20, 60, 60);
</code></pre>

<p>関連項目: <a href="#ref-stroke">stroke()</a>, <a href="#ref-noStroke">noStroke()</a>, <a href="#ref-fill">fill()</a></p>

</div><div id="ref-noStroke" class="section"><h1>noStroke</h1>

<p><code>noStroke()</code>は図形の縁を書かないように設定します。</p>

<pre><code class="language-prerender">// NoStrokeExample
noStroke(); fill(100);
rect(20, 20, 60, 60);
</code></pre>

<p>関連項目: <a href="#ref-stroke">stroke()</a>, <a href="#ref-fill">fill()</a>, <a href="#ref-noFill">noFill()</a></p>

</div><div id="ref-text" class="section"><h1>text</h1>

<p><code>text()</code>はキャンバスに文字列を表示します。表示する位置を座標で指定します。</p>

<pre><code class="language-prerender">// TextExample
size(150, 100, &#34;2D&#34;); fill(0); textSize(20);
text(&#34;こんにちは&#34;, 20, 50);
</code></pre>

<p>関連項目: <a href="#ref-textSize">textSize</a>, <a href="#ref-fill">fill</a>, <a href="#ref-textFont">textFont</a>.</p>

</div><div id="ref-textAlign" class="section"><h1>textAlign</h1>

<p><code>textAlign()</code>は文字を移り方を設定する。</p>

<pre><code class="language-render">size(300, 130, &#34;2D&#34;);
stroke(0);
fill(0);
textSize(15);
strokeWeight(5);
point(width/2, height/2);
frameRate(1);

function draw() {
  background(220);
  point(width/2, height/2);
  switch (frameCount % 12) {
    case 0:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(LEFT, TOP)&#34;, 10, 20);
      textAlign(LEFT, TOP);
      break;
    case 1:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(RIGHT, TOP)&#34;, 10, 20);
      textAlign(RIGHT, TOP);
      break;
    case 2:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(CENTER, TOP)&#34;, 10, 20);
      textAlign(CENTER, TOP);
      break;
    case 3:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(LEFT, BOTTOM)&#34;, 10, 20);
      textAlign(LEFT, BOTTOM);
      break;
    case 4:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(RIGHT, BOTTOM)&#34;, 10, 20);
      textAlign(RIGHT, BOTTOM);
      break;
    case 5:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(CENTER, BOTTOM)&#34;, 10, 20);
      textAlign(CENTER, BOTTOM);
      break;
    case 6:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(LEFT, CENTER)&#34;, 10, 20);
      textAlign(LEFT, CENTER);
      break;
    case 7:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(RIGHT, CENTER)&#34;, 10, 20);
      textAlign(RIGHT, CENTER);
      break;
    case 8:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(CENTER, CENTER)&#34;, 10, 20);
      textAlign(CENTER, CENTER);
      break;
    case 9:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(LEFT, BASELINE)&#34;, 10, 20);
      textAlign(LEFT, BASELINE);
      break;
    case 10:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(RIGHT, BASELINE)&#34;, 10, 20);
      textAlign(RIGHT, BASELINE);
      break;
    case 11:
      textAlign(LEFT, BASELINE);
      text(&#34;textAlign(CENTER, BASELINE)&#34;, 10, 20);
      textAlign(CENTER, BASELINE);
      break;
  }
  text(&#34;text&#34;, width/2, height/2);
}
</code></pre>

</div><div id="ref-textSize" class="section"><h1>textSize</h1>

<p><code>textSize()</code>は以降の <code>text()</code> での文字の大きさを設定します。</p>

<pre><code class="language-prerender">// TextSizeExample
fill(0);
textSize(50);
text(&#34;あ&#34;, 20, 80);
textSize(20);
text(&#34;か&#34;, 70, 30);
</code></pre>

<p>関連項目: <a href="#ref-text">text()</a>, <a href="#ref-textFont">textFont()</a>.</p>

</div><div id="ref-triangle" class="section"><h1>triangle</h1>

<p><code>triangle()</code>は三角形を描きます。3つの頂点を座標で指定します。</p>

<pre><code class="language-prerender">// TriangleExample
triangle(50, 10, 10, 80, 90, 80);
</code></pre>

<p>三角形の辺は現在のペンの色と太さで描きます。<code>stroke()</code>と<code>strokeWeigth()</code>を見てください。 三角形の内部は現在の塗りつぶしの色で塗りつぶします。<code>fill()</code>を見てください。</p>

</div><div id="ref-update" class="section"><h1>update</h1>

<p>更新する。</p>

</div><div id="ref-while" class="section"><h1>while</h1>

<p>指定された条件が真である間、 { … } の間に書いた文を繰り返します。</p>

<pre><code class="language-prerender">// WhileExample
fill(0);
var x = 0;
while (x &lt; 10) {
  text(str(x), 10+x*7, 15+x*8);
  x = x+1;
}
</code></pre>

<p>関連項目: <a href="#ref-for">for</a>, <a href="#ref-do">do</a>, <a href="#ref-break">break</a>, <a href="#ref-continue">continue</a>.</p>

</div><div id="ref-for" class="section"><h1>for</h1>

<p>ループ文といい、ある条件を満たすまで {} の中を繰り返します。丸括弧の中はセミコロン “;” で 3 つの部分に区切られ、以下の通りに実行されます。</p>

<ul>
<li>最初の部分は、繰り返しの始まる前に1度だけ実行されます</li>
<li>真ん中の部分は、繰り返しの条件です。この条件が満たされている間、{} の中を繰り返し実行します。</li>
<li>最後の部分は、{} の中を実行し終わった後、毎回呼ばれます。</li>
</ul>

<pre><code class="language-prernder">fill(0);
for (var i = 0; i &lt; 10; i++) {
  text(str(i), 10, i*10);
}
</code></pre>

<p>関連項目: <a href="#ref-while">while</a>, <a href="#ref-do">do</a>, <a href="#ref-break">break</a>, <a href="#ref-continue">continue</a>.</p>

</div><div id="ref-do" class="section"><h1>do</h1>

<p>ループの一つの種類。<a href="#ref-while">while</a>と違って、初めて条件を調べる前に一回ループの本体 を実行する。</p>

<pre><code class="language-prerender">do {
  fill(0);
  text(&#34;一回だけ実行する!&#34;, 5, 50);
} while (false);
</code></pre>

<p>関連項目: <a href="#ref-while">while</a>, <a href="#ref-for">for</a>, <a href="#ref-break">break</a>, <a href="#ref-continue">continue</a>.</p>

</div><div id="ref-if" class="section"><h1>if</h1>

<p>続く丸括弧内の条件が満たされた場合、直後のブロック({} の中)を実行します。 条件を満たさなかった場合は、<code>else</code>のブロックを実行します。もし<code>else</code>のブロックがない場合は、 何も実行しません。</p>

<pre><code class="language-prerender">// IfExample
fill(0);
if (10 &gt; 5) {
  text(&#34;10 &gt; 5&#34;, 10, 50);
} else {
  text(&#34;10 &lt;= 5 ?!&#34;, 10, 50);
}
</code></pre>

<p>関連項目: <a href="#ref-else">else</a></p>

</div><div id="ref-else" class="section"><h1>else</h1>

<p>条件付きの実行の<code>if</code>のブロックに条件が満たされないときに実行するブロック 指定する。</p>

<pre><code class="language-prerender">fill(0);
if (10 &lt; 5) {
  text(&#34;10 &lt; 5 ?!&#34;, 10, 50);
} else {
  text(&#34;10 &gt;= 5&#34;, 10, 50);
}
</code></pre>

<p>関連項目: <a href="#ref-if">if</a></p>

</div><div id="ref-case" class="section"><h1>case</h1>

<p><code>case</code>は、<code>switch</code>文の中で一つの値の分岐を表す。</p>

<p>関連項目: <a href="#ref-switch">switch</a>, <a href="#ref-default">default</a>.</p>

</div><div id="ref-switch" class="section"><h1>switch</h1>

<p><code>switch</code>文は一つの変数の値を検出して、複数の値に対して比べて多重分岐から 一つの分岐を実行する。</p>

<pre><code class="language-prerender">fill(0); textSize(30);
var x = 2;
switch (x) {
  case 0: text(&#34;〇&#34;, 10, 50); break;
  case 1: text(&#34;一&#34;, 10, 50); break;
  case 2: text(&#34;二&#34;, 10, 50); break;
  default: text(&#34;他&#34;, 10, 50); break;
}
</code></pre>

<p>関連項目: <a href="#ref-case">case</a>, <a href="#ref-default">default</a>.</p>

</div><div id="ref-default" class="section"><h1>default</h1>

<p><code>default</code>は、<a href="#ref-switch">switch</a>文の中でどの値でも当たらなかった場合の分岐を表す。</p>

<p>関連項目: <a href="#ref-switch">switch</a>, <a href="#ref-case">case</a>.</p>

</div><div id="ref-Loop-1" class="section"><h1>ループ</h1>

<p>ループは繰り返す実行の命令である。いくつの種類がある</p>

<ul>
<li><a href="#ref-for">for</a></li>
<li><a href="#ref-while">while</a></li>
<li><a href="#ref-do">do</a></li>
</ul>

</div><div id="ref-LabyrinthWalker" class="section"><h1>LabyrinthWalker</h1>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth2a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

var s = 44;

var x = 190;
var y = 310;

var dx = 0;
var dy = -1;

// canvas size (Variable aren&#39;t evaluated. Integers only, please.)
size(360, 360, &#34;2D&#34;);

// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);



// Use white fill color for drawing rectangles.
fill(255,255,255);
// Use white stroke color for drawing rectangles.
noStroke();
// Show image centered at (x,y).
imageMode(CENTER);
// Display the starting position of the walker.
image(imgWalker, x, y, s, s);

function turnLeft() {
  var tmp = dx;
  dx = dy;
  dy = -tmp;
}

var wallAhead() {
    var wallFound = false;
    var rx = -dy;
    var ry = dx;
    for (var i = -s/2-1; i &lt;= s/2+1; i++) {
        var c = get(x+dx*(s/2+3)+rx*i, y+dy*(s/2+3)+ry*i);
        wallFound = wallFound || brightness(c) &lt; 50;
    }
    return wallFound;
}

function moveForward() {
  rect(x-s/2, y-s/2, s, s);
  x += dx;
  y += dy;
  image(imgWalker, x, y, s, s);
}

function turnRight() {
  var tmp = dx;
  dx = -dy;
  dy = tmp;
}

var wallRight() {
  var rx = -dy;
  var ry = dx;
  var wallFound = false;
  for (var i = -s/2-1; i &lt;= s/2+1; i++) {
      var c = get(x + rx*(s/2+3)+dx*i, y + ry*(s/2+3)+dy*i);
      wallFound = wallFound || brightness(c) &lt; 50;
  }
  return wallFound;
}

var reachedGoal() {
  var c = get(x+dx*(s/2+3), y+dy*(s/2+3));
  return red(c) &lt; 50 &amp;&amp; green(c) &gt; 50;
}

function draw() {
  if (reachedGoal()) {
      fill(0,0,0);  // black.
      text(&#34;Finish!&#34;, x+s/2, y);
      noLoop();
  }
  if (!wallRight()) {
    turnRight();
    moveForward();
    moveForward();
  } else if (wallAhead()) {
    turnLeft();
  }
  moveForward();
}
</code></pre>

</div><div id="ref-LabyrinthBlank" class="section"><h1>1. 空迷路</h1>

<p>今回は、キャラクターの周りだけではなくて、動かす前に迷路全体を調べてみましょう。地図を作って、スタートやゴールの位置が判明してから、最短ルートを探します。プログラムは複雑になってくるので、アルゴリズムの面白い部分を見ることができます。以下のプログラムを読み込みしてから、「実行」のボタンを押してみましょう。</p>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth3a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

// Set up canvas size.
size(360, 360, &#34;2D&#34;);
// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);

var imgSave = null;
function draw() {
  if (imgSave != null) {
    image(imgSave, pmouseX, pmouseY, 44, 44);
  }
  imgSave = get(mouseX, mouseY, 44, 44);
  image(imgWalker, mouseX, mouseY, 44, 44);
}
</code></pre>

<p><a href="#ref-LabyrinthMapper">2. 地図作り</a></p>

</div><div id="ref-LabyrinthMapper" class="section"><h1>2. 地図作り</h1>

<p><a href="#ref-LabyrinthBlank">前に戻る</a></p>

<p>このプログラムは迷路の画像を解析して地図を作っていきます。
迷路の上に点をおいて、縦横にピクセルを調べながらグリッド形式で地図を作成します。迷路によってはもっと細かく地形を調べなければいけない場合があります。</p>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth3a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

// Step in pixels.
var s = 17;
// Size of the grid.
var n = 360/s;
// The grid. 0 means the cell is blocked. &gt;0 means the cell is open.
var grid[][];

var showMap = true;

// The starting point;
var sx = 0, sy = 0;
// The goal.
var gx = 0, gy = 0;

// canvas size (Variable aren&#39;t evaluated. Integers only, please.)
size(360, 360, &#34;2D&#34;);

// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);

// Allocate 2-dimensional array in 2 steps.
grid = new boolean[n][];
for (var i = 0; i &lt; n; i++) {
    grid[i] = new boolean[n];
}

// The loop counters that live across multiple mapStep invocations.
var i = 0, j = 0;

function mapStep() {
            var c = get(i*s+s/2, j*s+s/2);
            if (brightness(c) &gt; 200) {
                grid[i][j] = 999;
                if (showMap) {
                    fill(255, 255, 255);
                    rect(s*i, s*j, s/2, s/2);
                }
            }
            if (red(c) &gt; 100 &amp;&amp; green(c) &lt; 100) {
                sx = i;
                sy = j;
                if (showMap) {
                    fill(200, 0, 0);
                    rect(s*i, s*j, s/2, s/2);
                }
            } else if (green(c) &gt; 100 &amp; red(c) &lt; 100) {
                gx = i;
                gy = j;
                if (showMap) {
                    fill(0, 200, 0);
                    rect(s*i, s*j, s/2, s/2);
                }
            }
     j++;
     if (j &gt;= n) {
         j = 0;
         i++;
         if (i &gt;= n) {
             noLoop();
         }
     }
}


var next = 0;
var step = 50;

function draw() {
    if (showMap) {
        while (millis() &lt;= next) return;
        next = millis() + step;
    }
    mapStep();
}
</code></pre>

<p><a href="#ref-LabyrinthSearch">3. 最短の道</a></p>

</div><div id="ref-LabyrinthSearch" class="section"><h1>3. 最短の道</h1>

<p><a href="#ref-LabyrinthMapper">前に戻る</a></p>

<p>このプログラムは幅優先探索を使って最短の道を探しています。</p>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth3a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

// Step in pixels.
var s = 17;
// Size of the grid.
var n = 360/s;
// The grid. 0 means the cell is blocked. &gt;0 means the cell is open.
var grid[][];

var showMap = true;

// The starting point;
var sx = 0, sy = 0;
// The goal.
var gx = 0, gy = 0;

function CreateMap() {
    for (var i = 0; i &lt; n; i++) {
        for (var j = 0; j &lt; n; j++) {
            var c = get(i*s+s/2, j*s+s/2);
            if (brightness(c) &gt; 200) {
                grid[i][j] = 999;
            }
            if (red(c) &gt; 100 &amp;&amp; green(c) &lt; 100) {
                sx = i;
                sy = j;

            } else if (green(c) &gt; 100 &amp; red(c) &lt; 100) {
                gx = i;
                gy = j;

            }
        }
    }
    // Show the starting point.
    fill(200, 0, 0);
    rect(s*sx, s*sy, s/2, s/2);
    // Show the goal.
    fill(0, 200, 0);
    rect(s*i, s*j, s/2, s/2);
}

// Fixed queue length for simplicity. The expected maximum queue size is
// the the size of the grid, so should be well below 500.
var queueLength = 500;
var qx[] = new int[queueLength];
var qy[] = new int[queueLength];
var qhead = 0;
var qtail = 0;

function queuePush(x, y) {
    qx[qtail] = x;
    qy[qtail] = y;
    qtail = (qtail+1) % queueLength;
    // Note: in case of queue overflow, the queue contents will be lost
    // (misinterpreted as empty queue).
}

function queuePop() {
    if (qtail != qhead) {
        qhead = (qhead+1) % queueLength;
    }
}

var queueEmpty() {
    return qtail == qhead;
}

function visitCell(x, y, distance) {
    // Out of bounds checks.
    if (x &lt; 0 || x &gt;= n) return;
    if (y &lt; 0 || y &gt;= n) return;
    // Wall check.
    if (grid[x][y] == 0) return;
    // Distance check. If we find a shorter distance,
    // record it and return true. Note that all empty cells
    // originally have 999 recorded.
    if (grid[x][y] &gt; distance) {
        // Record the distance as shortest.
        grid[x][y] = distance;
        // Push the cell into the queue for further examination.
        queuePush(x, y);
        if (showMap) {
            fill(0, 0, 0);
        }
    }
}

function StartSearch() {
    // Using Breadth-first search in rectangular grid.
    // Put the goal position into the queue and search back towards
    // the start position.
    queuePush(gx, gy);
    grid[gx][gy] = 1;
}

// canvas size (Variable aren&#39;t evaluated. Integers only, please.)
size(360, 360, &#34;2D&#34;);

// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);

// Allocate 2-dimensional array in 2 steps.
grid = new boolean[n][];
for (var i = 0; i &lt; n; i++) {
    grid[i] = new boolean[n];
}

CreateMap();
StartSearch();

var next = 0;
var step = 250;
var found = false;

// The position during backtracing.
var bx, by;

function searchStep() {
    // While queue is not empty. Loop is implicit around draw().
    if (!queueEmpty()) {
        var x = qx[qhead];
        var y = qy[qhead];
        queuePop();

        fill(200, 200, 180);
        rect(s*x, s*y, s/2, s/2);
        var distance = grid[x][y];
        fill(0,0,0);
        text(&#34;&#34; + distance, x*s, y*s);

        if (x == sx &amp;&amp; y == sy) {
            exit();
            return;
        }
        // Go and try 4 neighbors.
        visitCell(x+1, y, distance+1);
        visitCell(x-1, y, distance+1);
        visitCell(x, y-1, distance+1);
        visitCell(x, y+1, distance+1);

    } else {
        // path not found.
        noLoop();
    }
}

function draw() {
    if (showMap) {
        while (millis() &lt;= next) return;
        next = millis() + step;
    }

    searchStep();
}
</code></pre>

<p><a href="#ref-LabyrinthBacktrace">4. 道の作り直し</a></p>

</div><div id="ref-LabyrinthBacktrace" class="section"><h1>4. 道の作り直し</h1>

<p><a href="#ref-LabyrinthSearch">前に戻る</a></p>

<p>このプログラムは最短のルートを見つけてから後ろから道を作り直します。</p>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth3a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

// Step in pixels.
var s = 17;
// Size of the grid.
var n = 360/s;
// The grid. 0 means the cell is blocked. &gt;0 means the cell is open.
var grid[][];

var showMap = true;

// The starting point;
var sx = 0, sy = 0;
// The goal.
var gx = 0, gy = 0;

function CreateMap() {
    for (var i = 0; i &lt; n; i++) {
        for (var j = 0; j &lt; n; j++) {
            var c = get(i*s+s/2, j*s+s/2);
            if (brightness(c) &gt; 200) {
                grid[i][j] = 999;
            }
            if (red(c) &gt; 100 &amp;&amp; green(c) &lt; 100) {
                sx = i;
                sy = j;
            } else if (green(c) &gt; 100 &amp; red(c) &lt; 100) {
                gx = i;
                gy = j;
            }
        }
    }
}

// Fixed queue length for simplicity. The expected maximum queue size is
// the the size of the grid, so should be well below 500.
var queueLength = 500;
var qx[] = new int[queueLength];
var qy[] = new int[queueLength];
var qhead = 0;
var qtail = 0;

function queuePush(x, y) {
    qx[qtail] = x;
    qy[qtail] = y;
    qtail = (qtail+1) % queueLength;
    // Note: in case of queue overflow, the queue contents will be lost
    // (misinterpreted as empty queue).
}

function queuePop() {
    if (qtail != qhead) {
        qhead = (qhead+1) % queueLength;
    }
}

var queueEmpty() {
    return qtail == qhead;
}

function visitCell(x, y, distance) {
    // Out of bounds checks.
    if (x &lt; 0 || x &gt;= n) return;
    if (y &lt; 0 || y &gt;= n) return;
    // Wall check.
    if (grid[x][y] == 0) return;
    // Distance check. If we find a shorter distance,
    // record it and return true. Note that all empty cells
    // originally have 999 recorded.
    if (grid[x][y] &gt; distance) {
        // Record the distance as shortest.
        grid[x][y] = distance;
        // Push the cell into the queue for further examination.
        queuePush(x, y);
        if (showMap) {
            fill(0, 0, 0);
            text(&#34;&#34; + distance, x*s, y*s);
        }
    }
}

function StartSearch() {
    // Using Breadth-first search in rectangular grid.
    // Put the goal position into the queue and search back towards
    // the start position.
    queuePush(gx, gy);
    grid[gx][gy] = 1;
}

// canvas size (Variable aren&#39;t evaluated. Integers only, please.)
size(360, 360, &#34;2D&#34;);

// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);

// Allocate 2-dimensional array in 2 steps.
grid = new boolean[n][];
for (var i = 0; i &lt; n; i++) {
    grid[i] = new boolean[n];
}

CreateMap();
StartSearch();

var next = 0;
var step = 250;
var found = false;

// The position during backtracing.
var bx, by;

function searchStep() {
    // While queue is not empty. Loop is implicit around draw().
    if (!queueEmpty()) {
        var x = qx[qhead];
        var y = qy[qhead];
        queuePop();

        fill(200, 200, 180);
        rect(s*x, s*y, s/2, s/2);
        var distance = grid[x][y];

        if (x == sx &amp;&amp; y == sy) {
            found = true;
            fill(0,0,0);
            bx = sx;
            by = sy;
            return;
        }
        // Go and try 4 neighbors.
        visitCell(x+1, y, distance+1);
        visitCell(x-1, y, distance+1);
        visitCell(x, y-1, distance+1);
        visitCell(x, y+1, distance+1);

    } else {
        // path not found.
        noLoop();
    }
}

var backTrace(nx, ny, distance) {
    if (nx &lt; 0 || nx &gt;= n) return false;
    if (ny &lt; 0 || ny &gt;= n) return false;
    if (grid[nx][ny] != distance) return false;
    // Found the backtrace step.
    if (showMap) {
        stroke(255,0,0);
        line(bx+s/4, by+s/4, nx+s/4, ny+s/4);
    }
    bx = nx;
    by = ny;
    return true;
}

function backTraceStep() {
    fill(255, 255, 100);
    rect(bx*s+s/4, by*s+s/4, s/2, s/2);
    if (bx == gx &amp;&amp; by == gy) {
        noLoop();
    }
    var distance = grid[bx][by];
    stroke(255, 255, 0);
    if (backTrace(bx-1, by, distance-1));
    else if (backTrace(bx+1, by, distance-1));
    else if (backTrace(bx, by-1, distance-1));
    else if (backTrace(bx, by+1, distance-1));
}

function draw() {
    if (found) {
        while (millis() &lt;= next) return;
        next = millis() + step;
    }

    if (found) {
        backTraceStep();
    } else {
        searchStep();
    }
}
</code></pre>

<p><a href="#ref-LabyrinthSolver">5. 完成版</a></p>

</div><div id="ref-LabyrinthSolver" class="section"><h1>5. 完成版</h1>

<p><a href="#ref-LabyrinthBacktrace">前に戻る</a></p>

<pre><code class="language-example">var imgLabyrinth = getImage(&#34;cc0/Labyrinth2a.png&#34;);
var imgWalker = getImage(&#34;cc0/Walker44.png&#34;);

// Step in pixels.
var s = 17;
// Size of the grid.
var n = 360/s;
// The grid. 0 means the cell is blocked. &gt;0 means the cell is open.
var grid[][];

var showMap = true;

// The starting point;
var sx = 0, sy = 0;
// The goal.
var gx = 0, gy = 0;

function CreateMap() {
    for (var i = 0; i &lt; n; i++) {
        for (var j = 0; j &lt; n; j++) {
            var c = get(i*s+s/2, j*s+s/2);
            if (brightness(c) &gt; 200) {
                grid[i][j] = 999;
                if (showMap) {
                    fill(255, 255, 255);
                    rect(s*i, s*j, s/2, s/2);
                }
            }
            if (red(c) &gt; 100 &amp;&amp; green(c) &lt; 100) {
                sx = i;
                sy = j;
                if (showMap) {
                    fill(200, 0, 0);
                    rect(s*i, s*j, s/2, s/2);
                }
            } else if (green(c) &gt; 100 &amp; red(c) &lt; 100) {
                gx = i;
                gy = j;
                if (showMap) {
                    fill(0, 200, 0);
                    rect(s*i, s*j, s/2, s/2);
                }
            }
        }
    }
}

// Fixed queue length for simplicity. The expected maximum queue size is
// the the size of the grid, so should be well below 500.
var queueLength = 500;
var qx[] = new int[queueLength];
var qy[] = new int[queueLength];
var qhead = 0;
var qtail = 0;

function queuePush(var x, var y) {
    qx[qtail] = x;
    qy[qtail] = y;
    qtail = (qtail+1) % queueLength;
    // Note: in case of queue overflow, the queue contents will be lost
    // (misinterpreted as empty queue).
}

function queuePop() {
    if (qtail != qhead) {
        qhead = (qhead+1) % queueLength;
    }
}

var queueEmpty() {
    return qtail == qhead;
}

function visitCell(var x, var y, var distance) {
    // Out of bounds checks.
    if (x &lt; 0 || x &gt;= n) return;
    if (y &lt; 0 || y &gt;= n) return;
    // Wall check.
    if (grid[x][y] == 0) return;
    // Distance check. If we find a shorter distance,
    // record it and return true. Note that all empty cells
    // originally have 999 recorded.
    if (grid[x][y] &gt; distance) {
        // Record the distance as shortest.
        grid[x][y] = distance;
        // Push the cell into the queue for further examination.
        queuePush(x, y);
        if (showMap) {
            fill(0, 0, 0);
            text(&#34;&#34; + distance, x*s, y*s);
        }
    }
}

function StartSearch() {
    // Using Breadth-first search in rectangular grid.
    // Put the goal position into the queue and search back towards
    // the start position.
    queuePush(gx, gy);
    grid[gx][gy] = 1;
}

// canvas size (Variable aren&#39;t evaluated. Integers only, please.)
size(360, 360, &#34;2D&#34;);

// Display the background (labyrinth).
image(imgLabyrinth, 1, 1, 360, 360);

// Allocate 2-dimensional array in 2 steps.
grid = new boolean[n][];
for (var i = 0; i &lt; n; i++) {
    grid[i] = new boolean[n];
}

CreateMap();
StartSearch();

var next = 0;
var step = 10;
var found = false;

// The position during backtracing.
var bx, by;

function searchStep() {
    // While queue is not empty. Loop is implicit around draw().
    if (!queueEmpty()) {
        var x = qx[qhead];
        var y = qy[qhead];
        queuePop();

        fill(200, 200, 180);
        rect(s*x, s*y, s/2, s/2);
        var distance = grid[x][y];

        if (x == sx &amp;&amp; y == sy) {
            found = true;
            fill(0,0,0);
            bx = sx;
            by = sy;
            return;
        }
        // Go and try 4 neighbors.
        visitCell(x+1, y, distance+1);
        visitCell(x-1, y, distance+1);
        visitCell(x, y-1, distance+1);
        visitCell(x, y+1, distance+1);

    } else {
        // path not found.
        noLoop();
    }
}

var backTrace(var nx, var ny, var distance) {
    if (nx &lt; 0 || nx &gt;= n) return false;
    if (ny &lt; 0 || ny &gt;= n) return false;
    if (grid[nx][ny] != distance) return false;
    // Found the backtrace step.
    if (showMap) {
        stroke(255,0,0);
        line(bx+s/4, by+s/4, nx+s/4, ny+s/4);
    }
    bx = nx;
    by = ny;
    return true;
}

function backTraceStep() {
    fill(255, 255, 100);
    rect(bx*s+s/4, by*s+s/4, s/2, s/2);
    if (bx == gx &amp;&amp; by == gy) {
        noLoop();
    }
    var distance = grid[bx][by];
    stroke(255, 255, 0);
    if (backTrace(bx-1, by, distance-1));
    else if (backTrace(bx+1, by, distance-1));
    else if (backTrace(bx, by-1, distance-1));
    else if (backTrace(bx, by+1, distance-1));
}

function draw() {
    if (showMap) {
        while (millis() &lt;= next) return;
        next = millis() + step;
    }

    if (found) {
        backTraceStep();
    } else {
        searchStep();
    }
}
</code></pre>

</div><div id="ref-Array" class="section"><h1>配列</h1>

<p><code>Array</code>は配列といい、データのリストを持っている。複数のデータを保存するとき、 番号を使って取り出せるのだ。</p>

<pre><code class="language-prerender">var x[] = {1, 2, 3};  // 配列をつくる
fill(0); text(x[0], 10, 20);
text(x[2], 10, 40);
var y[] = new int[10]; // 別の配列を作る
text(y[0], 10, 80);  // 最初は０が入っています。
</code></pre>

</div><div id="ref-HALF_PI" class="section"><h1>HALF_PI</h1>

<p><code>HALF_PI</code>は円周率の半分である。 <code>1.5707963267948966</code>.</p>

<pre><code class="language-prerender">arc(50, 50, 45, 45, 0, HALF_PI);
</code></pre>

<p>関連項目: <a href="#ref-PI">PI</a>, <a href="#ref-QUARTER_PI">QUARTER_PI</a>, <a href="#ref-TWO_PI">TWO_PI</a>.</p>

</div><div id="ref-QUARTER_PI" class="section"><h1>QUARTER_PI</h1>

<p><code>QUARTER_PI</code>は円周率の4分の1である。 <code>0.7853981633974483</code>.</p>

<pre><code class="language-prerender">arc(50, 50, 45, 45, 0, QUARTER_PI, HALF_PI);
</code></pre>

<p>関連項目: <a href="#ref-PI">PI</a>, <a href="#ref-HALF_PI">HALF_PI</a>, <a href="#ref-TWO_PI">TWO_PI</a>.</p>

</div><div id="ref-PI" class="section"><h1>PI</h1>

<p><code>PI</code>は円周率である。<code>3.141592653589793</code>.</p>

<pre><code class="language-prerender">size(150, 150, &#34;2D&#34;);
var ps = 0;
for (var x = 1; x &lt; 150; x += 1) {
  var s = sin(x/150*2*PI);
  line(x-1, 50+40*ps, x, 50+40*s);
  ps = s;
}
</code></pre>

<p>関連項目: <a href="#ref-HALF_PI">HALF_PI</a>, <a href="#ref-QUARTER_PI">QUARTER_PI</a>, <a href="#ref-TWO_PI">TWO_PI</a>.</p>

</div><div id="ref-TWO_PI" class="section"><h1>TWO_PI</h1>

<p><code>TWO_PI</code>は円周率の二倍である。<code>6.283185307179586</code>.</p>

<pre><code class="language-prerender">arc(50, 50, 45, 45, HALF_PI, TWO_PI);
</code></pre>

<p>関連項目: <a href="#ref-PI">PI</a>, <a href="#ref-HALF_PI">HALF_PI</a>, <a href="#ref-QUARTER_PI">QUARTER_PI</a>.</p>

</div><div id="ref-HashMap" class="section"><h1>HashMap</h1>

<p><code>HashMap</code>はハッシュテーブルデータ構造である。データはキーと値の組で保存され、 キーに対して値を素早く参照できる。</p>

<pre><code class="language-prerender">HashMap&lt;Integer, String&gt; map = new HashMap();
map.put(123, &#34;XYZ&#34;);
fill(0); text(map.get(123), 10, 30);
</code></pre>

<p>関連項目：<a href="#ref-get">get</a>, <a href="#ref-put">put</a>, <a href="#ref-entrySet">entrySet</a>.</p>

</div><div id="ref-get" class="section"><h1>get</h1>

<p><code>get()</code>は複数の意味持っている。</p>

<ul>
<li><a href="#ref-HashMap">HashMap</a>の場合、キーに対して値を取り出す。</li>
<li>画像の場合は、ピクセルデートを読み込みます。</li>
</ul>

<pre><code class="language-prerender">var img = getImage(&#34;cc0/Walker44.png&#34;)
image(img, 28, 28);

// 画像データを抽出する。
var frag = get(50, 50, 22, 22);
// 画像データ写す
image(frag, 72, 72, 28, 28);

// ピクセルの色を抽出する。
var c = get(50, 50);
// 抽出された色で長方形を描く。
rect(72, 0, 28, 28);
</code></pre>

</div><div id="ref-put" class="section"><h1>put</h1>

<p><code>put</code>は複数の意味を持っている。</p>

<ul>
<li><a href="#ref-HashMap">HashMap</a>の場合、キーに対して与えられた値を保存する。</li>
</ul>

</div><div id="ref-entrySet" class="section"><h1>entrySet</h1>

<p><a href="#ref-HashMap">HashMap</a>の場合、キーと値の組のセットを返す。そのセットはイテレータによって全ての組を取り出せる。</p>

<pre><code class="language-prerender">size(90, 200, &#34;2D&#34;); fill(0);
HashMap hm = new HashMap();
hm.put(1, &#34;one&#34;);
hm.put(12, &#34;one two&#34;);
hm.put(123, &#34;one two three&#34;);
for (it = hm.entrySet().iterator(); it.hasNext(); ) {
  Map.Entry en = it.next();
  var y = en.getKey();
  text(&#34;&#34; + en.getKey() + &#34;: &#34; + en.getValue(), 1, y+10);
}
</code></pre>

<p>関連項目: <a href="#ref-iterator">iterator</a>.</p>

</div><div id="ref-iterator" class="section"><h1>iterator</h1>

<p><code>iterator</code>は<a href="#ref-entrySet">entrySet</a>などのデート構造から全ての値の組を取り出せる。</p>

<p>関連項目: <a href="#ref-entrySet">entrySet</a>, <a href="#ref-getKey">getKey</a>, <a href="#ref-getValue">getValue</a>.</p>

</div><div id="ref-getKey" class="section"><h1>getKey</h1>

<p><a href="#ref-iterator">iterator</a>の場合、キーを返す。</p>

</div><div id="ref-getValue" class="section"><h1>getValue</h1>

<p><a href="#ref-iterator">iterator</a>の場合、値を返す。</p>

</div><div id="ref-next" class="section"><h1>next</h1>

<p><a href="#ref-iterator">iterator</a>の場合、次の組に進む命令する。</p>

</div><div id="ref-hasNext" class="section"><h1>hasNext</h1>

<p><a href="#ref-iterator">iterator</a>の場合、次の組が存在するかどうか判別する。</p>

</div><div id="ref-Variable" class="section"><h1>変数</h1>

<p>変数はプログラムの中に様々なデートを覚える仕組みである。</p>

<pre><code class="language-prerender">var nenrei = 12;
String namae = &#34;たろう&#34;;
fill(0); textSize(12);
text(namae + nenrei + &#34;才&#34;, 20, 20);
</code></pre>

</div><div id="ref-Object" class="section"><h1>オブジェクト</h1>

<p><code>Object</code>は関連するデータを束ね、複雑のデータ構造を表現できる。<a href="#ref-Variable">変数</a>に<code>Object</code>の型を付けられたら、</p>

<pre><code class="language-prerender">Object[] arr = {1, &#34;abc&#34;};
for (var i = 0; i &lt; arr.length; i++) {
  fill(0); text(str(arr[i]), 10, 20+i*20);
}
</code></pre>

</div><div id="ref-String" class="section"><h1>String</h1>

<p><code>String</code>は文字列の型を表し、言葉を覚える変数を作る。</p>

<pre><code class="language-prerender">String namae = &#34;たろう&#34;;
fill(0); text(namae, 20, 20);
</code></pre>

</div><div id="ref-PFont" class="section"><h1>PFont</h1>

<p><code>PFont</code>はフォントのデートを保存できる。</p>

<p>関連項目: <a href="#ref-loadFont">loadFont()</a>.</p>

</div><div id="ref-loadFont" class="section"><h1>loadFont</h1>

<p><code>loadFont</code>は書体データ(フォント)を読み込みする。</p>

<pre><code class="language-prerender">// TextFontExample
fill(0);
textFont(loadFont(&#34;Courier New&#34;, null), 12);
text(&#34;Courier New&#34;, 10, 20);
textFont(loadFont(&#34;Verdana&#34;, null), 15);
text(&#34;Verdana&#34;, 10, 40);
textFont(loadFont(&#34;Arial&#34;, null), 15);
text(&#34;Arial&#34;, 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-textFont">textFont()</a>, <a href="#ref-textSize">textSize()</a>, <a href="#ref-text">text()</a>.</p>

</div><div id="ref-textFont" class="section"><h1>textFont</h1>

<p><code>textFont()</code>は以降の <code>text()</code> で使われるフォントを設定します。</p>

<pre><code class="language-prerender">// TextFontExample
fill(0);
textFont(loadFont(&#34;Courier New&#34;, null), 12);
text(&#34;Courier New&#34;, 10, 20);
textFont(loadFont(&#34;Verdana&#34;, null), 15);
text(&#34;Verdana&#34;, 10, 40);
textFont(loadFont(&#34;Arial&#34;, null), 15);
text(&#34;Arial&#34;, 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-text">text()</a>, <a href="#ref-loadFont">loadFont()</a>, <a href="#ref-textSize">textSize()</a>.</p>

</div><div id="ref-color" class="section"><h1>color</h1>

<p><code>color</code>は色を表す値を作ります。R (赤)・G (緑)・B (青)それぞれを0から255までの３個の数値で指定して色を作り、その色をいろいろな API で使うことができます。</p>

<pre><code class="language-prerender">// ColorExample
var redColor = color(255, 0, 0);
var blueColor = color(0, 0, 255);
fill(redColor);
stroke(blueColor); strokeWeight(10);
rect(10, 10, 80, 80);
</code></pre>

<p>１つだけ数値を指定して、グレースケールで色を作ることもできます。0は黒、255は白、その中間は数値に応じた灰色を意味します。</p>

<p>関連項目: <a href="#ref-fill">fill()</a>, <a href="#ref-background">background()</a>, <a href="#ref-red">red()</a>, <a href="#ref-green">green()</a>, <a href="#ref-blue">blue()</a>, <a href="#ref-hue">hue()</a>, <a href="#ref-saturation">saturation()</a>, <a href="#ref-brightness">brightness()</a>, <a href="#ref-colorMode">colorMode()</a></p>

</div><div id="ref-abs" class="section"><h1>abs</h1>

<p><code>abs</code>は与えられた数の絶対値を返します。</p>

<pre><code class="language-prerender">// AbsExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = -10;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;abs(x) = &#39; + abs(x), 10, 60);
</code></pre>

</div><div id="ref-alpha" class="section"><h1>alpha</h1>

<p><code>alpha</code>は色から透明度を抽出する。</p>

<pre><code class="language-prerender">var opaque = color(255, 0, 0);
var transparent = color(255, 0, 0, 10);
fill(0); text(alpha(opaque), 10, 20); // 255
text(alpha(transparent), 20, 40); // 10
fill(opaque);
ellipse(50, 50, 20, 20);
fill(transparent);
rect(10, 10, 40, 40);
</code></pre>

</div><div id="ref-append" class="section"><h1>append</h1>

<p><code>append()</code>は配列にもう一つの要素分を追加する。</p>

<pre><code class="language-prerender">String[] namae = {&#34;たろう&#34;, &#34;花子&#34;};
append(namae, &#34;次郎&#34;);
fill(0); textSize(20);
for (var i = 0; i &lt; namae.length; i++) {
  text(namae[i], 10, 30+i*20);
}
</code></pre>

</div><div id="ref-concat" class="section"><h1>concat</h1>

<p><code>concat()</code>は２つの配列を結合する。</p>

</div><div id="ref-arc" class="section"><h1>arc</h1>

<p><code>arc</code>は円弧を描きます。</p>

<pre><code class="language-prerender">// ArcExample
arc(50, 50, 40, 20, 90, 360);
</code></pre>

<p>呼び方:</p>

<pre><code>arc(x, y, width, height, start, stop);
</code></pre>

<ul>
<li><code>x</code>, <code>y</code> –— 楕円の中心の座標</li>
<li><code>width</code>, <code>height</code> — 楕円の横幅と縦幅</li>
<li><code>start</code>, <code>stop</code> — 弧を描き始める角度と終わりの角度</li>
</ul>

<p>関連項目: <a href="#ref-ellipse">ellipse()</a>.</p>

</div><div id="ref-point" class="section"><h1>point</h1>

<p><code>point</code>は点を描きます。</p>

<pre><code class="language-prerender">// PointExample
strokeWeight(10);
point(50, 50);
</code></pre>

<p>呼び方:</p>

<pre><code>point(x,y);
</code></pre>

<ul>
<li>x, y — 点の座標。</li>
</ul>

<p>関連項目: <a href="#ref-strokeWeight">strokeWeight()</a>, <a href="#ref-stroke">stroke()</a>, <a href="#ref-line">line()</a>.</p>

</div><div id="ref-break" class="section"><h1>break</h1>

<p>ループ(<a href="#ref-while">while</a>, <a href="#ref-for">for</a>, <a href="#ref-do">do</a>)や<a href="#ref-switch">switch</a>から脱出する命令。</p>

</div><div id="ref-continue" class="section"><h1>continue</h1>

<p>ループ(<a href="#ref-while">while</a>, <a href="#ref-for">for</a>, <a href="#ref-do">do</a>)の実行を一旦止めて、ループの頭から実行再開する。</p>

<pre><code class="language-prerender">var i = 0;
while (i &lt; 10) {
  fill(0); text(str(i), 10, i*10);
  i++;
  continue;
  text(&#34;絶対実行しない&#34;, 50, 50);
}
</code></pre>

</div><div id="ref-binary" class="section"><h1>binary</h1>

<p><code>binary</code>は数を２進法(バイナリー)で表現する。返す値は文字列(<a href="#ref-String">String</a>).</p>

<pre><code class="language-prerender">x = 1023; // Binary 1111111111.
fill(0); text(binary(x), 10, 20);
text(binary(x, 5), 10, 40);
</code></pre>

<p>呼び方: <code>binary(input, num_digits)</code></p>

<ul>
<li><code>input</code> — 二進法で表現する数</li>
<li><code>num_digits</code> — 最大返す数字の上限</li>
</ul>

</div><div id="ref-blue" class="section"><h1>blue</h1>

<p><code>blue()</code>は色に対して青色の値を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-red">red()</a>, <a href="#ref-green">green()</a>, <a href="#ref-alpha">alpha()</a>.</p>

</div><div id="ref-green" class="section"><h1>green</h1>

<p><code>green()</code>は色に対して緑色の値を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-red">red()</a>, <a href="#ref-blue">blue()</a>, <a href="#ref-alpha">alpha()</a>.</p>

</div><div id="ref-red" class="section"><h1>red</h1>

<p><code>red()</code>は色に対して赤色の値を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-green">green()</a>, <a href="#ref-blue">blue()</a>, <a href="#ref-alpha">alpha()</a>.</p>

</div><div id="ref-hue" class="section"><h1>hue</h1>

<p><code>hue()</code>は色に対して色相を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-saturation">saturation()</a>, <a href="#ref-brightness">brightness()</a>.</p>

</div><div id="ref-saturation" class="section"><h1>saturation</h1>

<p><code>saturation()</code>は色に対して彩度を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-hue">hue()</a>, <a href="#ref-brightness">brightness()</a>.</p>

</div><div id="ref-brightness" class="section"><h1>brightness</h1>

<p><code>brightness()</code>は色に対して明度を返す。</p>

<p>関連項目: <a href="#ref-color">color</a>, <a href="#ref-saturation">saturation()</a>, <a href="#ref-hue">hue()</a>.</p>

</div><div id="ref-ceil" class="section"><h1>ceil</h1>

<p><code>ceil()</code> は与えられた数に対してそれより大きい最も近い整数を返します。</p>

<pre><code class="language-prerender">// CeilExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 9.3;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;ceil(x) = &#39; + ceil(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-floor">floor()</a>, <a href="#ref-round">round()</a></p>

</div><div id="ref-floor" class="section"><h1>floor</h1>

<p><code>floor()</code>は与えられた数に対してそれより小さいある最も近い整数を返します。</p>

<pre><code class="language-prerender">// FloorExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 9.3;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;floor(x) = &#39; + floor(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-ceil">ceil()</a>, <a href="#ref-round">round()</a></p>

</div><div id="ref-round" class="section"><h1>round</h1>

<p><code>round()</code>は与えられた数に対して最も近い整数を返します。</p>

<pre><code class="language-prerender">// RoundExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 9.3;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;round(x) = &#39; + round(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-ceil">ceil()</a>, <a href="#ref-floor">floor()</a></p>

</div><div id="ref-sin" class="section"><h1>sin</h1>

<p><code>sin()</code>は与えられた角度のサインを計算します。</p>

<pre><code class="language-prerender">// SinExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 30;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;sin(x) = &#39; + sin(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-cos">cos()</a>, <a href="#ref-tan">tan()</a></p>

</div><div id="ref-cos" class="section"><h1>cos</h1>

<p><code>cos()</code>は与えられた角度のコサインを計算します。</p>

<pre><code class="language-prerender">// CosExample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 60;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;cos(x) = &#39; + cos(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-sin">sin()</a>, <a href="#ref-tan">tan()</a></p>

</div><div id="ref-tan" class="section"><h1>tan</h1>

<p><code>tan()</code>は与えられた角度のタンジェントを計算します。</p>

<pre><code class="language-prerender">// Tanxample
size(200, 100, &#34;2D&#34;); fill(0); textSize(30);
var x = 45;
text(&#39;x = &#39; + x, 10, 30);
text(&#39;tan(x) = &#39; + tan(x), 10, 60);
</code></pre>

<p>関連項目: <a href="#ref-sin">sin()</a>, <a href="#ref-cos">cos()</a></p>

</div><div id="ref-this" class="section"><h1>this</h1>

<p><a href="#ref-class">class</a>の定義の中に自分自身のオブジェクトに参照する方法。</p>

<p>関連項目: <a href="#ref-class">class</a>.</p>

</div><div id="ref-dist" class="section"><h1>dist</h1>

<p><code>dist()</code>は２つの点の間の距離を計算します。点はそれぞれ x, y 座標で指定します。</p>

<pre><code>dist(x1, y1, x2, y2);
</code></pre>

<p>マウスが (50, 50) の点からどれくらい離れているかを表示する例は以下のようになります。</p>

<pre><code class="language-prerender">// DistExample
var x1 = 50, y1 = 50;
function draw() {
  background(255); fill(0);
  var x2 = mouseX, y2 = mouseY;
  line(x1, y1, x2, y2);
  text(dist(x1, y1, x2, y2), 50, 50);
}
</code></pre>

</div><div id="ref-cursor" class="section"><h1>cursor</h1>

<p><code>cursor()</code>はマウスのカーソルの形を指定する。</p>

<pre><code class="language-prerender">function setup() {
  frameRate(2);
}
// マウスのカーソルをキャンバス内に置きましょう。
var i = 0;
function draw() {
  i++;
  switch(i%6) {
    case 0: cursor(HAND); break;
    case 1: cursor(CROSS); break;
    case 2: cursor(ARROW); break;
    case 3: cursor(MOVE); break;
    case 4: cursor(TEXT); break;
    case 5: cursor(WAIT); break;
  }
}
</code></pre>

<p>関連項目: <a href="#ref-ARROW">ARROW</a>, <a href="#ref-CROSS">CROSS</a>, <a href="#ref-HAND">HAND</a>, <a href="#ref-MOVE">MOVE</a>, <a href="#ref-TEXT">TEXT</a>, <a href="#ref-WAIT">WAIT</a>.</p>

</div><div id="ref-ARROW" class="section"><h1>ARROW</h1>

<p>マウスカーソルの矢印の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-CROSS" class="section"><h1>CROSS</h1>

<p>マウスカーソルの十字の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-HAND" class="section"><h1>HAND</h1>

<p>マウスカーソルの手の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-MOVE" class="section"><h1>MOVE</h1>

<p>マウスカーソルの移動矢印の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-TEXT" class="section"><h1>TEXT</h1>

<p>マウスカーソルの縦線の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-WAIT" class="section"><h1>WAIT</h1>

<p>マウスカーソルの砂時計の形を表す。</p>

<p>関連項目: <a href="#ref-cursor">cursor()</a>.</p>

</div><div id="ref-exit" class="section"><h1>exit</h1>

<p><code>exit()</code>はスケッチの実行を終了する。</p>

</div><div id="ref-copy" class="section"><h1>copy</h1>

<p><code>copy()</code>画像の指定された部分をキャンバスの別のところでコピーする。</p>

<pre><code class="language-prerender">ellipse(50, 50, 40, 40);
copy(50, 50, 24, 24, 0, 0, 50, 50);
</code></pre>

<p>呼び方: <code>copy(x, y, w, h, dx, dy, dw, dh)</code></p>

<ul>
<li>x, y — コピーの元の長方形の左上の角のX,Y座標</li>
<li>w, h — コピーする資格の横幅と縦幅</li>
<li>dx, dy — コピーの目的地の長方形の左上の角のX,Y座標</li>
<li>dw, dh — コピーの目的地の横幅と縦幅</li>
</ul>

</div><div id="ref-key" class="section"><h1>key</h1>

<p>最後に押されたキーの文字または記号を文字列として保存している変数。 矢印などの文字ではないキーの判断には <code>keyCode</code> を使います。</p>

<pre><code class="language-prerender">// KeyCodeExample
size(200, 100, &#34;2D&#34;);
fill(0);
textSize(15);

function draw() {
  background(220);
  text(&#34;key &#34; + key, 10, 60);
  text(&#34;keyCode &#34; + keyCode, 10, 90);
}
</code></pre>

<p>関連項目: <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-keyTyped">keyTyped()</a>, <a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-keyCode" class="section"><h1>keyCode</h1>

<p>最後に押されたキーのコード。通常イベント関数で使います。 コードの一覧は<a href="#ref-keyCodes">keyCodes</a>を参照してください。</p>

<pre><code class="language-example">// KeyCodeExample
size(200, 100, &#34;2D&#34;);
fill(0);
textSize(15);

function draw() {
  background(220);
  text(&#34;key &#34; + key, 10, 60);
  text(&#34;keyCode &#34; + keyCode, 10, 90);
}
</code></pre>

<p>関連項目: <a href="#ref-key">key</a>, <a href="#ref-keyPressed">keyPressed()</a>, <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-keyTyped">keyTyped()</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-keyIsPressed" class="section"><h1>keyIsPressed</h1>

<p>Key が押されている場合は <code>true</code>, 離されている場合は <code>false</code> になります。</p>

<pre><code class="language-prerender">// KeyIsPressedExample
size(200, 100, &#34;2D&#34;);

function draw() {
  if (keyIsPressed) {
    background(60);
    fill(255);
  } else {
    background(220);
    fill(0);
  }
  text(&#34;keyIsPressed &#34; + keyIsPressed, 10, 60);
}
</code></pre>

<p>関連項目: <a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyPressed">keyPressed()</a>, <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-keyTyped">keyTyped()</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-keyPressed" class="section"><h1>keyPressed</h1>

<p><code>keyPressed()</code>を定義すると、キーが押されたたびに呼ばれます。</p>

<pre><code class="language-prerender">// KeyPressedExample
size(200, 100, &#34;2D&#34;);
fill(0);
textSize(10);
background(220);

var y = 10;
function keyPressed() {
  text(&#34;keyPressed() key &#34; + str(key) + &#34; keyCode &#34; + keyCode, 10, y);
  y += 10;
  if (y &gt; height) {
    background(220);
    y = 10;
  }
}
</code></pre>

<p>関連項目: <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-keyTyped">keyTyped()</a>, <a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>, <a href="#ref-keyIsPressed">keyIsPressed</a>.</p>

</div><div id="ref-keyTyped" class="section"><h1>keyTyped</h1>

<p><code>keyTyped()</code>を定義すると、キーボードの文字または数字や記号のキーが押されたときに呼ばれます。</p>

<pre><code class="language-prerender">// KeyTypedExample
size(200, 100, &#34;2D&#34;);
fill(0);
textSize(10);
background(220);

var y = 10;
function keyTyped() {
  text(&#34;keyTyped() key &#34; + str(key) + &#34; keyCode &#34; + keyCode, 10, y);
  y += 10;
  if (y &gt; height) {
    background(220);
    y = 10;
  }
}
</code></pre>

<p>関連項目: <a href="#ref-keyPressed">keyPressed()</a>, <a href="#ref-keyReleased">keyReleased()</a>, <a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-keyReleased" class="section"><h1>keyReleased</h1>

<p><code>keyReleased()</code>を定義すると、キーが離されるたびに呼ばれます。</p>

<pre><code class="language-prerender">// KeyReleasedExample
size(200, 100, &#34;2D&#34;);
fill(0);
textSize(10);
background(220);

var y = 10;
function keyReleased() {
  text(&#34;keyReleased() key &#34; + str(key) + &#34; keyCode &#34; + keyCode, 10, y);
  y += 10;
  if (y &gt; height) {
    background(220);
    y = 10;
  }
}
</code></pre>

<p>関連項目: <a href="#ref-keyPressed">keyPressed()</a>, <a href="#ref-keyTyped">keyTyped()</a>, <a href="#ref-key">key</a>, <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-keyCodes" class="section"><h1>keyCodes</h1>

<p>以下のキーの条件を調べるときに先に<code>key == CODED</code>を確かめなければなりません。 <a href="#ref-CODED">CODED</a>に参照。</p>

<ul>
<li>矢印キー: <a href="#ref-UP">UP</a>, <a href="#ref-DOWN">DOWN</a>, <a href="#ref-RIGHT">RIGHT</a>, <a href="#ref-LEFT">LEFT</a>.</li>
<li><a href="#ref-ALT">ALT</a>, <a href="#ref-CONTROL">CONTROL</a>, <a href="#ref-SHIFT">SHIFT</a>.</li>
</ul>

<p><strong>注意</strong>: Processing.jsではブラウザの環境によって使えないキーコードがあります。 以下のスケッチで確認ください。</p>

<pre><code class="language-example">// Keycodes
function setup() {
  size(400, 200, &#34;2D&#34;);
  textSize(30);
  textFont(loadFont(&#34;fixed&#34;));
  fill(0);
}

function draw() {
  background(220);
  if (keyPressed) {
    text(&#34;keyPressed&#34;, 10, 30);
    String label;
    if (key == CODED) {
      label = &#34;keyCode &#34; + str(keyCode) + &#34; &#34;;
      switch (keyCode) {
        case UP: label = label + &#34;UP&#34;; break;
        case DOWN: label = label + &#34;DOWN&#34;; break;
        case LEFT: label = label + &#34;LEFT&#34;; break;
        case RIGHT: label = label + &#34;RIGHT&#34;; break;
        case ESC: label = label + &#34;ESC&#34;; break;
        case ENTER: label = label + &#34;ENTER&#34;; break;
        case SHIFT: label = label + &#34;SHIFT&#34;; break;
        case ALT: label = label + &#34;ALT&#34;; break;
        case CONTROL: label = label + &#34;CONTROL&#34;; break;
        case RETURN: label = label + &#34;RETURN&#34;; break;
        case ENTER: label = label + &#34;ENTER&#34;; break;
        case DELETE: label = label + &#34;DELETE&#34;; break;
        case BACKSPACE: label = label + &#34;BACKSPACE&#34;; break;
      }
      text(label, 10, 100);
    } else {
      label = &#34;key &#39;&#34; + str(key) + &#34;&#39;&#34;;
      text(label, 10, 100);
    }
    return;
  }
}
</code></pre>

</div><div id="ref-UP" class="section"><h1>UP</h1>

<p>上の矢印キーのコード。一覧は<a href="#ref-keyCodes">keyCodes</a>に参照。 <code>keyCode == UP</code>を調べる先に<code>key == CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-DOWN" class="section"><h1>DOWN</h1>

<p>下の矢印キーのコード。一覧は<a href="#ref-keyCodes">keyCodes</a>に参照。 <code>keyCode == DOWN</code>を調べる先に<code>key == CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-ALT" class="section"><h1>ALT</h1>

<p>「Alt」キーのコード。 <code>keyCode == ALT</code>を調べる先に<code>key == CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-CONTROL" class="section"><h1>CONTROL</h1>

<p>「Ctrl」キーのコード。 <code>keyCode == CONTROL</code>を調べる先に<code>key == CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-SHIFT" class="section"><h1>SHIFT</h1>

<p>「Shift」キーのコード。 <code>keyCode == SHIFT</code>を調べる先に<code>key == CODED</code>を確かめなければなりません。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-BACKSPACE" class="section"><h1>BACKSPACE</h1>

<p>「Backspace」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-TAB" class="section"><h1>TAB</h1>

<p>「Tab」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-ENTER" class="section"><h1>ENTER</h1>

<p>「Enter」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-RETURN" class="section"><h1>RETURN</h1>

<p>「Return」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-ESC" class="section"><h1>ESC</h1>

<p>「Esc」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-DELETE" class="section"><h1>DELETE</h1>

<p>「Delete」キーのコード。</p>

<p>関連項目: <a href="#ref-keyCode">keyCode</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-CODED" class="section"><h1>CODED</h1>

<p><a href="#ref-keyCode">keyCode</a>の値を調べるときに先<code>key == CODED</code>を確かめる必要なときがあります。 詳しく<a href="#ref-keyCodes">keyCodes</a>に参照。</p>

<p>関連項目: <a href="#ref-key">key</a>, <a href="#ref-keyCodes">keyCodes</a>.</p>

</div><div id="ref-getImage" class="section"><h1>getImage</h1>

<p><code>getImage()</code>は画像のデートを読み込んでいます。ないProcessing.jsでは
ファイルシステムにアクセスできないので、画像データはサーバからダウンロード されます。ダウンロードは時間かかる場合があるので、<code>@pjs
preload</code>の命令が 必要です。</p>

<pre><code class="language-prerender">var walker = getImage(&#34;cc0/Walker44.png&#34;);
image(walker, 10, 10, 80, 80);
</code></pre>

<p>関連項目: <a href="#ref-image">image()</a>.</p>

</div><div id="ref-PImage" class="section"><h1>PImage</h1>

<p>画像の形。</p>

<p>関連項目: <a href="#ref-getImage">getImage()</a>, <a href="#ref-image">image()</a>.</p>

</div><div id="ref-PAudio" class="section"><h1>PAudio</h1>

<p>音のデータ。</p>

<pre><code class="language-prerender">var sound = getSound(&#34;cc0/explosion.ogg&#34;);

function mouseClicked() {
  sound.play();
}

function draw() {
  if (!sound.audio.paused) {
    background(50);
  } else {
    background(220);
  }
}
</code></pre>

<p><strong>注意</strong>：標準のProcessing.jsに存在しない。</p>

<p>関連項目: <a href="#ref-SoundGallery">音のギャラリー</a></p>

</div><div id="ref-getSound" class="section"><h1>getSound</h1>

<p>音のデータをロードする。 <a href="#ref-PAudio">PAudio</a>に参照</p>

<p><strong>注意</strong>：標準のProcessing.jsに存在しない。</p>

</div><div id="ref-imageMode" class="section"><h1>imageMode</h1>

<p><code>imageMode()</code>は画像の移す位置を設定します。</p>

<ul>
<li><code>imageMode(CENTER)</code>は画像を写すときに中心点を使う設定します。</li>
<li><code>imageMode(CORNER)</code>は画像を写すときに左上の角を使う設定します。</li>
<li><code>imageMode(CORNERS)</code>は画像の左上と右下の角を使う設定します。</li>
</ul>

<pre><code class="language-prerender">// SpriteExample
var img = getImage(&#34;cc0/baloon1-170x200.png&#34;);
imageMode(CORNERS);
image(img, 50, 50, 85, 100);
</code></pre>

<pre><code class="language-prerender">// SpriteExample
var img = getImage(&#34;cc0/baloon1-170x200.png&#34;);
imageMode(CORNER);
image(img, 50, 50, 85, 100);
</code></pre>

<pre><code class="language-prerender">// SpriteExample
var img = getImage(&#34;cc0/baloon1-170x200.png&#34;);
imageMode(CENTER);
image(img, 50, 50, 85, 100);
</code></pre>

</div><div id="ref-image" class="section"><h1>image</h1>

<p><code>image()</code>は画像データをキャンバスにスタンプのように表示します。</p>

<p>呼び方:</p>

<pre><code>image(img, x, y, width, height);
</code></pre>

<ul>
<li>x, y — 画像を表示する座標。

<ul>
<li>imageModeでCENTERを指定した場合、画像の中心の座標。</li>
<li>imageModeでCORNERまたはCORNERSを指定した場合、画像の左上の角の座標。</li>
</ul></li>
<li>width, height — 画像の横幅と高さ。

<ul>
<li>imageModeでCORNERSを指定の場合は横幅と高さではなく、右下の角の座標として扱われます。</li>
</ul></li>
</ul>

<pre><code class="language-prerender">// ImageExample
imageMode(CENTER);
image(getImage(&#34;cc0/banana-200x113&#34;), 50, 50, 100, 67);
</code></pre>

<p>関連項目: <a href="#ref-getImage">getImage()</a>, <a href="#ref-imageMode">imageMode()</a>.</p>
</div></body></html>